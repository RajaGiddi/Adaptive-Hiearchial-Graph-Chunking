Explorability in Pushdown Automata
Ayaan Bedi # 
Chennai Mathematical Institute, India

Karoliina Lehtinen # 
CNRS Researcher, Aix-Marseille Universit , LIS

arXiv:2511.04048v1 [cs.FL] 6 Nov 2025

Abstract
We study explorability, a measure of nondeterminism in pushdown automata, which generalises
history-determinism. An automaton is k-explorable if, while reading the input, it suffices to follow k
concurrent runs, built step-by-step based only on the input seen so far, to construct an accepting one,
if it exists. We show that the class of explorable PDAs lies strictly between history-deterministic
and fully nondeterministic PDAs in terms of both expressiveness and succinctness. In fact increasing
explorability induces an infinite hierarchy: each level k defines a strictly more expressive class than
level k 1, yet the entire class remains less expressive than general nondeterministic PDAs. We then
introduce a parameterized notion of explorability, where the number of runs may depend on input
length, and show that exponential explorability precisely captures the context-free languages. Finally,
we prove that explorable PDAs can be doubly exponentially more succinct than history-deterministic
ones, and that the succinctness gap between deterministic and 2-explorable PDAs is not recursively
enumerable. These results position explorability as a robust and operationally meaningful measure
of nondeterminism for pushdown systems.
2012 ACM Subject Classification Theory of computation Automata extensions
Keywords and phrases Pushdown automata, nondeterminism, explorability, history-determinism
Funding This work is in part funded by ANR Project QuaSy ANR-23-CE48-0008 and part supported
by ReLaX, Research Lab in Computer Science, CNRS IRL 2000.
Acknowledgements We are grateful to Aditya Prakash for his insightful input and helpful discussions.

1

Introduction

Determinism and nondeterminism are central themes in theoretical computer science, particularly in the study of computational models in automata theory and complexity theory.
Nondeterminism often brings either increased expressive power or more succinct representations. For example, in the case of finite automata, while nondeterminism does not increase
expressive power, it allows for exponentially more succinct representations. In contrast, for
Turing machines, while expressiveness remains unchanged, the distinction between deterministic and nondeterministic variants leads to the foundational open problem of the field: P vs.
NP. Pushdown automata (PDAs), which are strictly more powerful than finite automata,
exhibit both increased expressiveness and non recursively ennumerable succinctness when
nondeterminism is introduced.
While deterministic models are often seen as overly restrictive, unrestricted nondeterminism functions as a computational superpower, capable of always making the correct choice.
This raises the question of whether is there a meaningful spectrum between determinism and
full nondeterminism and how to usefully quantify the degree of nondeterminism.
A variety of measures of nondeterminism have been suggested for pushdown automata.
Goldstine et al. quantified nondeterminism by counting the minimum number of guesses (in
bits) needed to accept a word, which induces an infinite hierarchy of complexity classes and
language subclasses [2], while Han et al. measure computation tree width and ambiguity[4].
Another approach is to restrict nondeterminism to bounded or context-dependent forms [1].
For example, Herzog characterizes pushdown automata with at most k nondeterministic

2

Explorability in Pushdown Automata

choices as unions of k deterministic context-free languages, noting tradeoffs in descriptive
complexity that are sometimes not recursively bounded [10]. Models with regulated nondeterminism (using control sets or stack-content constraints) describe language classes that
lie strictly between the deterministic and fully nondeterministic cases.
One well-studied intermediate form of nondeterminism is bounded ambiguity, which
restricts the number of accepting runs per input for instance, to at most one (unambiguity),
or at most k, for some fixed constant k. In parallel, another notable form of restricted
nondeterminism that simplifies decision problems like universality and game solving is historydeterminism (HD), also known as good-for-games (GFG) nondeterminism [9]. The key idea
behind HD automata is that their nondeterministic choices can be resolved in a forward,
step-by-step manner, based only on the input processed so far, without any need to anticipate
future input symbols [3].
Recently, history-deterministic pushdown automata (HD-PDAs) have been shown to
be more expressive than their deterministic counterparts [3]. Moreover, HD-PDAs were
shown to enjoy at least exponential succinctness over deterministic PDAs. However, when
compared to general nondeterministic PDAs, HD-PDAs are strictly less expressive and also
less succinct, by at least doubly exponential factor [3]. Furthermore, at least one of these
succinctness gaps is far from tight, since the succinctness gap between nondeterministic and
deterministic PDAs is not recursively enumerable (RE) [6] the question of which one, or
both, was left open.
This significant gap between HD-PDAs and general nondeterministic PDAs motivates
the exploration of intermediate classes of languages. By identifying and characterizing such
classes, we aim to better understand the trade-offs between expressiveness, succinctness,
and the degree of nondeterminism permitted in pushdown computations. Therefore we
study the notion of explorability, which was introduced for finite state automata by Hazard
and Kuperberg [8] as a generalisation of history-determinism. Intuitively, k-explorability
corresponds to having k separate runs that are being resolved on-the-fly, with the requirement
that for any word in the language, at least one of the runs should be accepting.
The problem of recognizing explorable NFAs is ExpTime-complete for automata over finite
words and for B chi automata. In the setting of infinite words, recognizing ω-explorable automata is also ExpTime-complete for safety and co-B chi acceptance conditions [8]. Moreover
Hazard, Idir and Kuperberg showed that there is a trade-off between the explorability of an
automaton and the number of priorities needed to recognise all ω-regular languages [7].
Our contributions: In this work, we extend the study of PDAs by investigating their
expressiveness and succinctness across increasing levels of explorability. We show that
explorable PDAs are strictly more expressive than HD-PDAs. Furthermore, we establish an
infinite hierarchy within the class of explorable PDAs: k-explorable PDAs are strictly less
expressive than (k + 1)-explorable ones. We also prove that the class of explorable PDAs is
strictly less expressive than the class of general nondeterministic PDAs.
We then ask under what conditions does the class of explorable PDAs match the expressive
power of the class of fully nondeterministic PDAs? We answer this by introducing a
parameterized notion of explorability, where the number of concurrent runs may depend
on the length of the input word. In this setting, we demonstrate a hierarchy between
constant-bounded, linearly-bounded, and exponentially-bounded explorability. Exponentially
explorable PDAs capture exactly the class of context-free languages, and are therefore
equivalent in expressiveness to general nondeterministic PDAs. While we only study this
notion over PDAs, the notion of parameterised explorability might be of independent interest,
as is the case for parameterised ambiguity.

A. Bedi and K. Lehtinen

We then turn our attention to the succinctness of explorable PDAs. We prove that
the succinctness gap between HD-PDAs and general explorable PDAs is at least doubly
exponential. Moreover, we establish that a similar doubly exponential gap persists even
when explorability is restricted to a constant. Delving further into the non-RE separation
between deterministic and nondeterministic models, we show that the succinctness gap
between DPDAs and 2-explorable PDAs is not recursively enumerable. That is, there exists
no recursive bound on the size blow-up required to simulate certain 2-explorable PDAs by
DPDAs.

2

Preliminaries

Pushdown Automaton
 Definition 1. A pushdown automaton (PDA) is a computational model that extends
finite automata with a stack, providing additional memory. Formally, a PDA is a tuple
M = (Q, Σ, Γ, δ, q0 , Z0 , F ) where:
Q is a finite set of states,
Σ a finite input alphabet,
Γ a finite stack alphabet,
 2
δ : Q (Σ {ε}) Γ 2Q Γ is the transition function,
q0 Q is the initial state,
Z0 Γ is the initial stack symbol, and
F Q is the set of accepting states.
At any point during computation, the mode of a PDA is of the form Q Γ and is
determined by its current state and the symbol at the top of the stack. The behavior of the
PDA is defined by the transition function δ, which may allow multiple transitions from the
same mode. The transitions enabled at a mode, runs, accepting runs, and language of an
automaton are defined as usual [11]. The size of a PDA is the product of the number of
states |Q| and the number of stack symbols |Γ|.
PDAs accept exactly the class of languages known as context-free languages (CFLs). A
PDA is said to be deterministic if for all q Q, a Σ {ε}, and X Γ, the set δ(q, a, X)
contains at most one element, and if δ(q, ε, X) = , then δ(q, a, X) = for all a Σ. The
class of languages accepted by deterministic PDAs (DPDAs) is called the class of deterministic
context-free languages (DCFLs), and it is known that DCFL CFL, i.e., DCFLs form a
strict subset of CFLs [11].

3

Explorability of Pushdown Automata

The k-Explorability Game for Pushdown Automata
As described by Hazard et al. [8], explorability restricts or measures the amount of nondeterminism an automaton needs to accept a language, while allowing more flexibility than
history determinism (HD). For a given k N, an automaton is said to be k-explorable if,
when processing an input, it is sufficient to keep track of most k runs in order to construct
an accepting run, if one exists. This generalizes the idea of HD automata, which corresponds
to the special case where k = 1.
We now introduce the k-explorability game [8] over a PDA, which generalises the gamebased definition of HD-automata, and captures a hierarchy of nondeterministic behavior

3

4

Explorability in Pushdown Automata

in pushdown automata (PDAs). This game is played between two players Spoiler and
Determiner on a nondeterministic PDA A.
 Definition 2 (k-Explorability Game for PDAs). Let P = (Q, Σ, Γ, δ, q0 , Z0 , F ) be a pushdown
automaton, and let k N be a fixed integer. The k-explorability game on P is played on the
arena Qk (Γ )k , where each of k tokens maintains its own copy of the control state and
stack content. We can imagine a configuration here as k tokens say 1... k placed in the space
Q Γ and arena is the set of all possible configurations.
The game proceeds as follows:
Initialization: The initial configuration is a k-tuple of identical PDA configurations:
S0 = ((q0 , Z0 ), . . . , (q0 , Z0 ))
Gameplay: At each step i 1, from configuration Si 1 :
1. Spoiler chooses an input symbol ai Σ.
2. Determiner responds by selecting the next configuration
Si = ((qi1 , γi1 ), . . . , (qik , γik )) (Q Γ )k
l
l
such that for each l {1, . . . , k}, there exists a path of transitions in P from (qi 1
, γi 1
)
l
l
to (qi , γi ) of the form:
ε

ε a

i
l
l
(qi 1
, γi 1
) 

(qil , γil )

where each step is valid under the PDA transition relation δ.
The play continues for an infinite number of steps and a word w = a1 a2 . . . is formed.
A play is an infinite sequence π = S0 t1 S1 t2 S2 . . . such that: S0 = ((q0 , Z0 ), . . . , (q0 , Z0 )) 
(Q Γ )k , is a k-tuple of initial state q0 and initial stack configuration Z0 . And for all i 1,
tl

i
l
l
and for each l {1, . . . , k}, the transition (qi 1
, γi 1
) 
(qil , γil ) is valid according to the

PDA s transition relation δ.
The play is won by Determiner if for every finite prefix of w = a1 a2 . . . that is in the
language of L, i.e. w = a1 . . . an L(P ), there exists at least one token l {1, . . . , k} such
that the sequence of configurations for token l forms an accepting run of P on w . Otherwise,
Spoiler wins the game.

We say that a PDA P is k-explorable (Explk -PDA) if Determiner has a winning strategy
in the k-explorability game on P . If P is k-explorable for some k N, we say that P is
explorable (Expl-PDA). When k = 1 then it s exactly the game characterising HD ([9, Section
3 ]) and therefore HD is 1-explorable.
 Definition 3. We define Explk -CFL as the class of languages recognized by k-explorable
nondeterministic pushdown automata. That is,
Explk -CFL = {L Σ | L is recognized by a k-explorable PDA}.
 Definition 4. We define Expl-CFL as the class of languages recognized by explorable
S
pushdown automata. Formally, Expl-CFL = k N Explk -CFL.
 Definition 5 (k-Run in a k-Explorable PDA). Let P = (Q, Σ, Γ, δ, q0 , Z0 , F ) be a nondeterministic pushdown automaton, and let k N. A k-run of P on an input word w = a1 a2 . . . an Σ 
in the k-explorability setting is a sequence of k-tuples of configurations:
R = (C01 , . . . , C0k ), (C11 , . . . , C1k ), . . . , (Cn1 , . . . , Cnk )
such that:

A. Bedi and K. Lehtinen

For all 1 l k, C0l = (q0 , Z0 ) is the initial configuration (same across all tokens),
For each step i = 1, . . . , n and each token l = 1, . . . , k, there exists a valid PDA path:
a

i
l

Cil ,
Ci 1

A k-run R is said to be accepting if there exists at least one token l {1, . . . , k} such
that the final configuration Cnl = (qnl , γnl ) satisfies qnl F (i.e., the control state is accepting).

Parameterised Explorability
The notion of k-explorability captures bounded nondeterminism by allowing the Determiner
to explore at most k computational branches in parallel. However, in many settings, the
amount of explorability required to resolve nondeterminism may grow with the size of the
input. To capture this, we extend the explorability to a parameterized framework, where the
number of tokens available to Determiner is not fixed but instead given by a function f (n)
of the input length n.
 Definition 6 (f (n)-Parameterized Explorability Game). Let P = (Q, Σ, Γ, δ, q0 , Z0 , F ) be a
nondeterministic pushdown automaton, and let f : N N be a computable function. The
f (n)-parameterized explorability game on P is played between two players, Spoiler and
Determiner, as follows:
Initialization: Spoiler announces a number n N, declaring the maximum length of the
word he will play. Determiner is then given f (n) tokens, each representing a copy of the
PDA configuration.
Gameplay: is similar to as defined for k-Explorability Game.
The play is won by Determiner if for every prefix of the Spoiler s word in w Σ n L(P ),
there exists at least one token l {1, . . . , f (n)} such that the sequence of configurations for
token l forms an accepting run of P on w. Otherwise, Spoiler wins.
A PDA P is said to be f (n)-explorable if Determiner has a winning strategy in the
f (n)-parameterized explorability game on P . Let C be a class of functions (such as O(n));
we define the language class:
ExplC -CFL = {L Σ | an f (n)-explorable PDA P such that L = L(P ) and f (n) C}.

4

Expressiveness

It is well known that deterministic pushdown automata (DPDA) recognize the class of
deterministic context-free languages (DCFL), which is strictly contained within the class of
context-free languages (CFL) recognized by nondeterministic pushdown automata (PDA).
Recent work by Guha et al. [3] shows that HD-PDA defines a language class (HD-CFL) that
properly extends DCFL but is still strictly contained within CFL.
 Theorem 7 (Theorem 4.1 [3]). DCFL HD-CFL CFL
We now turn our attention to the expressive power of explorable pushdown automata.
Analogous to the results on history-deterministic pushdown automata, we investigate the
hierarchy induced by allowing increasing, but bounded, explorability. In particular, we show
that k-explorability induces an infinite hierarchy, which is strictly contained within CFL:
 Theorem 8. For all k, Explk -CFL Explk+1 -CFL CFL.

5

6

Explorability in Pushdown Automata

4.1

Explk -CFL Explk+1 -CFL

To prove that (k + 1)-explorable pushdown automata are strictly more expressive than
k-explorable ones, we consider, for each i {1, . . . , k}, the language Li := {an bin | n N}.
Sk+1
We then define the language L := i=1 Li .
We claim that L is accepted by a k + 1-explorable pushdown automaton but cannot
be recognized by any k-explorable pushdown automaton. Intuitively, accepting L requires
distinguishing among k different linear relations between the number of a s and b s, each
corresponding to a different multiplicative factor i. This requires k distinct tokens, one for
each Li , which cannot be simulated with fewer runs.
 Lemma 9. The language L is recognized by a (k + 1)-explorable pushdown automaton.
Proof. For each i, Li is recognized by a DPDA Di that pushes i symbols onto the stack at
each a and then compares the number of b s to the stack height by popping the stack as it
reads b. The automaton that initially nondeterministically chooses among ε-transitions to
the initial states of each Di for i [1..k + 1] clearly recognises L and is k + 1-explorable since
Determiner can win the k + 1-explorability game by having each Di explored by a distinct
token.

L is not k-explorable
We observe that a k-explorable PDA P would have to accept some words an b and their

continuation an b along the same run, as Determiner does not have enough tokens to check
membership to each Li with a disjoint run. Therefore, there would be some accepting runs
that can be extended into another accepting run via more b-transitions. Then, we build a
PDA P which is similar to P , except that after seeing an accepting state, it can also read
c s instead of b s. We show, using a pumping argument, that this automaton would recognise
a language that is not CFL, leading to a contradiction. The difficulty in this proof is that we
do not have an exact description for the language recognised by P as it depends on exactly
which pairs of words P accepts along a single run, and the hypothesis of k-explorability only
tells us that this must occur for some pairs , for each n. However, we can describe L(P )
in enough detail to show that it is, in any case, not CFL.
We define the language Li,j,n := {an bin cjn }, where i, j, n N. Each Li,j,n consists of
strings with block sizes linearly dependent on n, with coefficients i and j for the lengths of
the b and c blocks, respectively.
Now we define a language LS such that for each n N, the set of words of the form
n m k
a b c L is contained in a finite and nonempty union of such languages Li,j , n, but the
choice of the coefficents is and js may vary with n. Formally, given S = (Sn )n N where each
Sn Z+ Z+ is finite and non-empty.

[
[
 {an } 
LS :=
{bin cjn } ,
n N

(i,j) Sn

That is, for every n N, LS consists of a finite union of languages of the form Li,j,n .
In this way, LS represents a non-uniform or n-dependent union of linearly structured
languages.
 Lemma 10. Given S = (Sn )n N where each Sn Z+ Z+ is finite and non-empty, the
language LS is not context-free.

A. Bedi and K. Lehtinen

The proof is a pumping argument, detailed in the Appendix.
Sk+1
 Lemma 11. The language L := i=1 Li , where Li := {an bin | n N}, is not recognized
by any k-explorable PDA.
Proof. Assume, towards contradiction, that there exists a k-explorable PDA A that recognizes
L. Since L includes strings of the form an bin for i {1, 2, . . . , k + 1}, and we only have k
tokens, by the pigeonhole principle, for any fixed n, for any winning Determiner strategy,
there must be at least one token that accepts two different strings an bin and an bjn for some
i < j. That means that the run built by this token visits an accepting state at least twice.
We define Sn as the pairs i, j such that there is an accepting run over an bjn of which a prefix
accepts an bin . By the pigeonhole principle, that Sn is non-empty for all n.
We use this fact to construct a new PDA Ac that accepts the language LS , for S = (Sn )n N
as described above. As previously shown, LS is not context-free, so the existence of such a
PDA will lead to a contradiction.
Let A = (Q, Σ, Γ, qI , , F ), with Q = {q0 , q1 , . . . , qn } and qI = q0 . We define a modified
PDA Ac = (Q Q , Σ , Γ, qI , , F ), where:
Σ = {a, b, c},
Q = {q0 , q1 , . . . , qn } is a copy of Q,
F = {qf | qf F },
 = c , with c defined as:
1. For every qf F , add (qf , X, ε, qf , X) for all X Γ (transferring control to the new
state space),
2. For every transition (qi , X, b, qj , γ) , add (qi , X, c, qj , γ) c replacing the
input symbol b with c in the copied state space.
3. For every (qi , X, ε, qj , γ) , add (qi , X, ε, qj , γ) c . - to replicated ε-transitions
Intuitively, the modified PDA simulates the original input an bin on A, and then, upon
acceptance, continues in the copied state space simulating a second phase where each b
transition is replaced by a c-transition, thereby accepting strings of the form an bin c(j i)n .
For each pair in some Sn , there is an accepting run in P that extends into another
accepting run. Therefore P accepts the word an bin c(j i)n for each (i, j) Sn . Hence Ac
accepts LS L. This implies that LS is context-free (by intersection with the regular language
a b c ) a contradiction, since we have already shown in Lemma 4.2 that LS CFL.
Thus, no k-explorable PDA can recognize L.

We conclude the first half of Theorem 8: For all k N, the class of languages recognized
by (k + 1)-explorable pushdown automata strictly contains the class of languages recognized
by k-explorable pushdown automata. That is, Explk -CFL Explk+1 -CFL.

4.2

Expl-CFL CFL

To separate the class of explorable context-free languages from the full class of context-free
languages, we consider the following language:
Lblock := {(a #) bn | n = length of some a-block} .
Intuitively, Lblock consists of strings formed by a sequence of a-blocks separated by #,
followed by a block of b s whose length matches the length of some previous a-block. For
example, the string a3 #a5 #a2 #b5 Lblock , since the final b-block has length 5, which
matches the length of the second a-block.

7

8

Explorability in Pushdown Automata

While Lblock is clearly CFL, the intuition is that each of Determiner s tokens can only
compare one block of a s to the final block of b s, and as the number of a-blocks is unbounded,
so is the number of tokens that she would need to win the explorability game, making this
language not explorable.
 Lemma 12. Lblock CFL
Proof. A nondeterministic PDA can guess and store the length of one of the a-blocks on the
stack, then skip the rest of the input until it reaches the b-block, and verify the count by
popping the stack.

 Lemma 13. The language Lblock := {(a #) bn | n = length of some a-block} is not
recognized by an explorable PDA.
Proof. Assume, towards a contradiction, that for some k, Lblock Explk -CFL, i.e., it is
recognized by an k-explorable PDA. Observe that Explk -CFL is closed under intersection
with regular languages since taking a product with a deterministic finite automaton does not
increase the explorability of the PDA.
Let us take the regular language R = (a#)k+1 b . Then the intersection

Lk block := Lblock R = (a #)k+1 bn | n = length of some a-block
must also be in Explk -CFL under our assumption.
So the problem comes down to showing that Lk block 
/ Explk -CFL. Assume, towards a
contradiction, that Lk block is recognized by a k-explorable PDA A. Let w be a word in
(a #)k+1 . In the k-explorability game, since there are k + 1 a-blocks but only k tokens, if
all the blocks are of distinct lengths then, at least one token will accept both a word and
its prefix. Therefore, for each such w, there are some accepting runs that can be extended

into another accepting run via more b-transitions. Let Sw
be the set of pairs of integers such
i
j

that both wb and wb are accepted along the same run. Note that for each (i, j) Sw
, both

i and j match the length of some a-block in w and j > i. Call S = (Sw )w W where W

consists of (a #)k+1 such that Sw
is non-empty. Note that Sw
is necessarily non-empty for
w in which the block lengths are all distinct, and may or may not be empty otherwise.
As in Lemma 11 we can then build a second PDA, in which ε-transitions move from the
final states of a first copy of A to the same state in another copy, in which b-transitions are
replaced by c-transitions. Taking the product with a DFA for (a #)k+1 b c , this results in
a PDA A for the language:

Lblock S := wbi ci j | w (a #)k+1 , (i, j) Sw
.
By construction, if Lk block Explk -CFL, then Lblock S is accepted by the A . However,
from Lemma 14, this language is not CFL. This contradicts that it is recognized by a PDA.
Hence, Lk block 
/ Explk -CFL, and therefore Lblock 
/ Explk -CFL as well.

 Lemma 14. Given S = (Sw
)w (a #)k+1 in which some Sw
are non-empty, then the
language Lblock S is not context-free.

The proof, detailed in the appendix, consists of a pumping argument.
 Theorem 15. Expl-CFL CFL
Proof. Follows directly from Lemma 12 and Lemma 13: we have exhibited a context-free
language Lblock which is not in Explk -CFL, for any k, establishing the strict inclusion.

A. Bedi and K. Lehtinen

5

Parametrized Explorability and Its Expressiveness

In the previous section, we established the existence of an expressiveness gap across different
fixed levels of exploration. However, in that analysis, the exploration was treated as a
constant, independent of the input. In this section, we investigate the consequences of
parameterising the level of exploration as a function of the input length, as characterised
by the parameterised explorability game. This allows us to study how expressiveness scales
when the exploration level is allowed to grow with the size of the input.
We are led to the following conjecture, which captures the hierarchy induced by varying
exploration bounds:
ExplO(1) -CFL ExplO(n) -CFL Explexp -CFL = CFL
Here, we write exp for the set of exponential functions, that is, in O(2p(n) ) for some
polynomial p. Intuitively ExplO(f (n)) -CFL is the class of languages recognised by a pushdown
automaton that is allowed to have at most O(f (n)) tokens for exploration, where n is the
length of the input. Observe that ExplO(1) -CFL is precisely the the class Expl-CFL discussed
so far.
The conjecture above posits a strict hierarchy of language classes recognized by explorable
pushdown automata under increasing exploration bounds. At the lower end, constantbounded exploration (O(1)) is provably limited in expressiveness, while allowing exploration
to grow linearly with input length (O(n)) yields strictly greater power. Ultimately, permitting
exponential exploration suffices to recover the full class of context-free languages.
 Lemma 16. ExplO(1) -CFL ExplO(n) -CFL
Proof. In the previous section, we saw that the language
Lblock := {(a #) bn | n = length of some a-block}
cannot be recognized by any k-explorable pushdown automaton for any k N ( Lemma 13).
Consequently, we conclude that Lblock 
/ ExplO(1) -CFL.
However, it is straightforward to observe that Lblock ExplO(n) -CFL. Indeed, we can
construst a PDA that nondeterministically chooses an a-block and compares it with the
b-block. Since the total number of such a-blocks is bounded by the length of the input word,
it suffices to use O(n) runs to cover all possible cases. Within each run, the automaton can
compare the length of an a-block with the number of b s at the end of the input. If a match
is found, the input is accepted. Hence, the inclusion ExplO(1) -CFL ExplO(n) -CFL is strict.

 Lemma 17. Explexp -CFL = CFL
Proof. Let L CFL. Then there exists a PDA M that accepts L. It is well known that for
any PDA, there exists an equivalent PDA that accepts the same language but does not use
ε-transitions[13], so w.l.o.g. we assume M to have no ε-transitions.
Let m be the maximum number of nondeterministic transitions possible from any state in
M . Consider an input word w of length n. Since the machine can make at most m choices
at each step, the number of possible runs of M on input w is at most mn .
Therefore, the total number of possible runs grows at most exponentially with the length
of the input. Therefore exponentially many tokens are enough to explore each of the possible
runs. Hence, CFL Explexp -CFL.
The reverse inclusion is trivial. Therefore, CFL = Explexp -CFL.

9

10

Explorability in Pushdown Automata

6

Succinctness

We now shift our focus to the succinctness of pushdown automata. Recall that the size of a
PDA is the product |Q| |Γ|, where Q is the set of states and Γ is the stack alphabet. We
argue that significant succinctness gaps exist between different levels of exploration. We
build on several results from the work of Guha et al. [3].
We demonstrate that explorable PDAs are not only more expressive than historydeterministic PDAs (HD-PDAs) and deterministic PDAs (DPDAs), but also more succinct.
Furthermore, we show that fixing the degree of exploration yields a double-exponential gap
in succinctness when compared to unrestricted explorable PDAs.

6.1

Explorable vs. HD-PDA

Guha et al [3] showed that a nondeterministic pushdown automaton (PDA) can recognize the
language Ln = (0+1) 1(0+1)n 1 using only O(log(n)) space, while any history-deterministic
PDA (HD-PDA) requires space exponential in n. This establishes a double-exponential gap
in succinctness between PDAs and HD-PDAs.
In this work, we demonstrate that the same double exponential gap occurs already
between HD-PDAs and explorable PDAs. Specifically, we show that an explorable PDA
can recognize Ln using only O(log(n)) space, highlighting the succinctness advantage of
explorability over history-determinism.
 Lemma 18. There exists an explorable PDA of size O(log n) recognising Ln.
Proof. Guha et all. [3] described a PDA Pn that recognises Ln in O(log(n)) space. We adjust
their construction to get P n that is also n-explorable. The PDA Pn nondeterministically
guesses the nth bit from the end of the input, checks that it is a 1 or a 0 and stored that in
the state space, then switches to a counting gadget that verifies the input ends in exactly n
steps, as follows:
1. It pushes the binary representation of n 2 onto the stack. For example, if n = 8, then 110
is pushed onto the stack with 0 at the top. Note that log(n 2) states suffice for pushing
the binary representation of n 2. If n = 1, then instead of pushing anything onto the
stack, the automaton directly moves to a final state without any enabled transitions.
2. Then Pn moves to a state that attempts to decrement the counter by one for each
successive input letter, as follows: when an input letter is processed, it pops 0s until a 1
is at the top of the stack, say m 0s. Then, it replaces the 1 with a 0, and finally pushes
m 1s back onto the stack before processing the next letter. If the stack empties before a
1 is found, then the counter value is 0, and the automaton moves to an accepting state or
dummy state depending on the initial 1-check. Note that O(log n) states again suffice for
this step.
3. To make the automaton Pn , we keep the description of Pn and add an ε-transition from
the final state and dummy state (as deribed above) back to the initial state.
Now, consider the n tokens, numbered 0, 1, . . . , n 1, and an input word w = w1 w2 . . . wm .
Each token (i) starts the logarithmic counting at input positions j such that j mod n = i.
Therefore, if the input contains a 1 at the nth position from the end, then there exists at
least one token that reaches the final state of the PDA. Furthermore, if an additional input
symbol is read after reaching the final state, the ε-transition takes the token to the initial
state, and the log-space counter is reinitialized. This allows the token to repeat the counting
procedure from the next position.

A. Bedi and K. Lehtinen

Thus, P n has O(log n) states and is n-explorable. Note that for all n, P n uses only
three stack symbols: 0, 1, and . Altogether, the size of P n is O(log n), and Pn recognises
Ln .

We can now state the following succinctness result.
 Theorem 19. Expl-CFL can be double-exponentially more succinct than HD-PDA.

6.2

k-Explorable PDA vs. Explorable PDA

We now compare the succinctness gap between PDA of bounded and unbounded explorability,
using the following family of languages.
Lmod n := (0 + 1)<n (1(0 + 1)n 1 ) 
That is, a word belongs to Lmod n if every position that is a multiple of n, counting from
the end, contains a 1.
 Lemma 20. Any k-explorable
pushdown automaton (PDA) that accepts the language

k n
Lmod n must have size at least n2
Proof. We define the stack height of a configuration c = (q, γ) as sh(c) = |γ| 1, and we define
steps of a run as follows. Consider a run c0 τ0 c1 τ1 cn 1 τn 1 cn . A position s {0, . . . , n}
is a step if for all s s, we have that sh(cs ) sh(cs ), that is, the stack height is always at
least sh(cs ) after position s. Any infinite run of a PDA has infinitely many steps. We have
the following observation:
 Remark 21. If two runs of a PDA have steps s0 and s1 , respectively, with the same mode,
then the suffix of the run following the step s0 can replace the suffix of the other run following
the step s1 , and the resulting run is a valid run of the PDA.
Consider an infinite run of a pushdown automaton (PDA) P on some input word wω
where w is of length n. Each position of the run is characterised by an indexed mode, which is
a tuple consisting of the current state, the top symbol of the stack, and the current position
in w (an integer in [0, n 1]). Since the set of states Q, the stack alphabet Γ, and the
input positions [0, n] are all finite, the total number of distinct indexed modes is bounded by
|Q| |Γ| n.
Since an infinite run must contain infinitely many steps and there are only finitely many
indexed modes, by the pigeonhole principle, some indexed mode must appear infinitely often
as a step. That is, there exists a mode m = (q, γ, i), where q Q, γ Γ, and i {0, 1, . . . , n},
such that m occurs at infinitely many points in the run as a step.
Now consider a k-explorable pushdown automaton. Determiner s strategy witnessing this
induces a tuple of k runs in parallel on a given input word. As in the previous argument,
in each individual run, some indexed mode must appear infinitely often as a step. Since
there are at most |Q| |Γ| n possible indexed modes for a single run, the number of possible
combinations of indexed modes across all k runs is at most (|Q| |Γ| n)k .
This gives an upper bound on the number of distinct indexed mode combinations that
can occur as a step infinitely many times in a k-run of a k-explorable PDA.
Now, observe that there are 2n distinct
binary words of length n. Suppose the number

k n
of distinct modes is strictly less than n2 . Then, by the pigeonhole principle, there must
exist at least two distinct words, say w1 and w2 , such that the infinite k-run (k-tuple of
infinite runs) ρ1 and ρ2 , induced by the k-explorable PDA on inputs w1ω and w2ω , respectively,
contain infinitely many steps at the same index modulo n, and with identical step modes.

11

12

Explorability in Pushdown Automata

Let these step modes be m1 , m2 , . . . , mk , one for each of the k runs for both w1 and w2 ,
occurring at positions s1 , s2 , . . . , sk in ρ1 , and at corresponding positions s 1 , s 2 , . . . , s k in ρ2 ,
such that for each α [k], we have
sα mod n = s α mod n & |sα | > n & |s α | > n
Since w1 and w2 are distinct words, they differ at some position, say j. WLOG, assume
that w1 [j] = 1 while w2 [j] = 0. For w1 at every instance where the input length modulo the
word length (n) is j 1, one of runs in ρ1 must reach an accepting state (since the bit at
position j in w1 is 1). However, in the run ρ2 , at every such instance (i.e., when the position
modulo n is j 1), no accepting state can be reached in ρ2 , since the corresponding bit in
w2 is 0.
Let s = max(s1 , . . . , sk ), and consider a position p where the modulo n is j 1 and p > s.
At position p, ρ1 should have an accepting state in one of the explorable runs as explained
before. Now, the contradiction is as follows: WLOG, assume that the accepting state is at
the first run in ρ1 . This means that the suffix of first run ρ2 starting from position s 1 + 1
can be replaced with the suffix of first run in ρ1 starting from position s1 + 1 and this will
yield a valid run (by remark 4.1.1) and accepting run (see figure 1). After replacement, the
resultant run is on a word which is some concatenation of substrings of w2 and w1 ; however
since s1 and s 1 share the same index, the index of the final state also remains the same.
As s 1 > n the initial occurrences of w2 [j] will lie at some (0 mod n)th bit from the end;
therefore, the resultant word is not in Lmod n . However, after the replacement, P accept the
word, leading to a contradiction.

 Theorem 22. Expl-CFL can be double-exponentially more succinct than Explk -CFL.
Proof. As in the Lemma 18, an explorable PDA (more specifically an n-explorable PDA)
can recognise Lmod n using log(n) space. In contrast, we showed
that for each fixed k,

k n
any k-explorable PDA recognizing Lmod n must use at least n2 size. This establishes a
double exponential gap in succinctness between fully explorable PDAs and their k-explorable
counterparts.

6.3

Deterministic vs. Explorable PDA

Theorem 5.1 in the work of Guha et al. [3] establishes that HD-PDAs can be exponentially
more succinct than DPDAs. Since HD-PDAs correspond precisely to 1-explorable PDAs, it
follows that the same exponential succinctness gap holds between DPDAs and explorable
PDAs. Hartmanis [6] proved that the relative succinctness of representing deterministic
context-free languages (DCFLs) using deterministic versus nondeterministic pushdown automata (PDAs) is not bounded by any recursive function. In this work, we adapt and extend his
proof technique to establish a similar result for deterministic and explorable PDAs showing
that the succinctness gap between them is likewise non-recursive.
Let M be a Turing machine, for an input x, let ID0 (x) denote the initial configuration
of M on input x, and let ID1 (x), ID2 (x), . . . denote the successive configurations during the
computation.
If x = a1 a2 . . . an , we define the reversal of x as: xr = an an 1 . . . a1 .
We now define VALC[M ] as the set of valid computations of M , represented with
alternating reversals of configurations, as follows:
{ID0 (x)#[ID1 (x)]r #ID2 (x)# #ID2k (x) | ID2k (x) is a halting configuration of M } .

A. Bedi and K. Lehtinen

index:

s2

sk

s 3

j

s k

mk

3
..
.
k

s 2

m2

2
m3

s 1
m1

1

m2

3
..
.
k

s3

m1

1
2

s1

13

m3
mk

Figure 1 The figure illustrates two k-runs of a k-explorable PDA P . On the left, we depict the
k-run ρ1 , where at a position p an accepting state is reached along the run. On the right, we show ρ2 ,
in which an identical modes appears at the same index modulo n, allowing a suffix of ρ1 (beginning
from the first run s step following the matching mode) to be replayed on ρ2 .

Each valid computation alternates between standard and reversed configurations, ending
in a halting configuration. We also assume that 2k > 3, that is TM takes at least 3 steps
before halting.
We also define the set of invalid computations as: INVALC[M ] = Γ \ VALC[M ],

INVALC is Explorable
More specifically, in this section we show that INVALC is 2-explorable.
Given a Turing machine M = (Q, Σ, Γ, δ, q0 , qaccept , qreject ) and an input word w Σ , a
string α belongs to VALC(M ) if and only if the following conditions hold:
1. α is of the form α = #C0 #C1 #C2 # #CN # where each Ci is a configuration encoded
as a string over (Γ Q) .
2. Each configuration Ci contains exactly one symbol from Q, indicating that the machine
is in exactly one state at each computation step.
3. C0 encodes the initial configuration of M on input w: the tape contains w followed by
blanks, the head is at the leftmost position, and the machine is in state q0 .
4. CN is a halting configuration i.e., the state in CN is either qaccept or qreject .
5. For every i such that 0 i < N , the configuration Ci+1 is a valid successor of Ci under
M s transition function δ. And alternate between standard and reversed representations
(i.e., Ci is reversed if i is odd).
We observe that among the five conditions defining membership in VALC[M ], the first four
are regular. Therefore, when checking for INVALC[M ] only checking (5) ensuring correct
transitions between adjacent configurations does not hold requires deeper computational
power.

Verifying Condition 5 with 2-Explorability
We claim that a 2-explorable PDA suffices to verify that condition (5) does not hold. To do
so, we define a 2-explorable machine consisting of a nondeterministic choice between two

14

Explorability in Pushdown Automata

sub-automata, each of which checks the validity of half the pairs of configurations:
One sub-automaton processes the sequence in blocks of the form:
#C0 #C1 #C2 #C3 # #CN #
verifying that each reversed configuration C2i+1 is a valid successor of the standard
configuration C2i .
The other sub-automaton processes the alternating pattern:
#C0 #C1 #C2 #C3 #C4 # #CN #
verifying that each standard configuration C2i+2 is a valid successor of the reversed
configuration C2i+1 .
Each sub-automaton independently verifies consistency across transitions. Note that
checking whether a configuration C follows validly from C (according to M s transition
function) can be done by a DPDA as follows:
Push the entire configuration C onto the stack while reading.
Then, read the next configuration C and pop from the stack, comparing symbols and
using the transition function δ to ensure that the head movement, state change, and tape
content evolve correctly.
Any mismatch leads to acceptance
Thus, the only nondeterminism is in the initial choice between the two sub-automata, after
which each is deterministic. This means that only two runs suffice for Determiner in the
2-exploration game, and hence the machine 2-explorable.
Since the first four conditions are regular and the fifth is 2-explorable, we conclude that
the set of invalid computations INVALC[M ] is recognizable by a 2-explorable PDA.
 Lemma 23. [6, Lemma 1] INVALC[M ] is a deterministic context-free language (DCFL)
if and only if L(M ) is finite.
Proof. If L(M ) is finite, then the set of valid accepting computations VALC[M ] is finite
and so its complement INVALC[M ] is co-finite. Since the class of regular languages is closed
under complementation, and all finite or co-finite languages are regular, it follows that
INVALC[M ] is regular and hence a DCFL.
Conversely, if L(M ) is infinite, then VALC[M ] is not context-free (since checking the
validity of more than two consecutive Turing Machine configurations is not context-free and
our machines take at least three steps) and since DCFLs are closed under complement, its
complement INVALC[M ] cannot be a DCFL.

 Definition 24. We say that the relative succinctness of representing deterministic contextfree languages (DCFLs) by 2-explorable and deterministic pushdown automata is not recursively bounded if there is no recursive function F such that for every 2-explorable-PDA A
accepting a DCFL, there exists an equivalent deterministic PDA D such that |D| F (|A|),
where |A| and |D| denote the descriptional sizes of A and D, respectively.
 Theorem 25. The relative succinctness of representing deterministic context-free languages
by explorable and deterministic PDAs is not recursively bounded.
Proof. Suppose, for contradiction, that there exists a recursive function F such that for
every 2-explorable-PDA A accepting a DCFL, there exists a deterministic PDA D equivalent
to A with |D| F (|A|).

A. Bedi and K. Lehtinen

Then given a TM M , let A be the 2-explorable PDA that recognizes INVALC[M ]. We
can compute F (|A|) and enumerate all deterministic PDAs D1 , D2 , . . . , Ds of sizes up to
F (|A|). Then L(A) is not deterministic iff none of these Dj is equivalent to A, which is
semi-decidable, by comparing memberships on all strings in Σ . If none of them is equivalent
to A, we conclude that L(A) is not a DCFL. Therefore, by Lemma 23 we can enumerate
the set {M | L(M ) is infinite } which would contradict Rice s theorem [12]. Hence, R is not
recursively enumerable. Therefore, such a function F cannot exist.

7

Conclusion

In this work, we introduced and studied the notion of explorability for PDAs, refining the
landscape between deterministic and nondeterministic computation. Building on the concept
of history-determinism, we defined the class of k-explorable PDAs and established a strict
expressiveness hierarchy based on the number of concurrent explorations permitted.
On the succinctness front, we established that explorable PDAs can be doubly exponentially more succinct than PDAs with fixed constant bound on explorability. Furthermore,
the succinctness gap between DPDAs and 2-explorable PDAs is not recursively enumerable,
extending the classic non-RE gap between deterministic and nondeterministic PDAs.
Despite these advances, several intriguing questions remain open. The introduction of
parameterized explorability gives rise to a rich landscape of intermediate classes such as log n 
explorable, poly-explorable or n-explorable PDAs whose expressiveness and succinctness
properties are yet to be systematically studied. Furthermore, while we have established
tight bounds in several cases, the exact succinctness gap between general explorable PDAs
and fully nondeterministic PDAs remains unresolved. Addressing these questions may not
only deepen our understanding of the complexity-theoretic trade-offs between determinism
and nondeterminism in the context of PDAs, but could also shed new light on longstanding
questions regarding the structure of context-free languages. While we do not have any
hope that explorability of PDA is decidable because HD is undecidable, it seems likely
that in the context of visibly pushdown automata, explorability might have some better
algorithmic properties, like recognizability, lower complexity universality, Gale-Stewart games
and inclusion.
