{"method": "fixed", "num_chunks": 94, "avg_chunk_len": 795.3829787234042, "std_chunk_len": 39.75994626879442, "max_chunk_len": 800, "min_chunk_len": 412, "total_chars": 74766, "compression_ratio": 1.0006420030495145, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025\n\narXiv:2511.03814v1 [cs.FL] 5 Nov 2025\n\nSTATE COMPLEXITY OF MULTIPLE CONCATENATION\n\nJozef Jir sek\n(A)\n\n(A,B)\n\nGalina Jir skov \n\n(C,D)\n\nInstitute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk\n\n(C)\n\nMathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automa", "ta. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.\n\nKeywords: regular languages, multiple concatenation, state complexity\n\n1. Introduction\nGiven formal languages L1 , L2 , . .", ". , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.\n\nJozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ. Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov", "[5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s univer", "sal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concat", "enation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain", "exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .\n\nState Complexity of Multiple Concatenation\n\n3\n\nFor a fi", "nite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be comple", "te; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states", "p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w i", "n Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R =", "(Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ. Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final state", "s F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .\n\nCorollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assum", "e that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 ,", ". . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the n", "ext definition.\n\nState Complexity of Multiple Concatenation\n\n5\n\nDefinition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).\n\nNotice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs", "A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .\n4\n\nProof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand", "s3 \n/ S3 is not valid, which gives the right inequality.\n\nWe now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.\n\nTheorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accept", "ing L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G. Jir skov \n\nand for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ).\n\n(2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 .\n\n(4)\n\nProof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).\n\nLet fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).\n\nLet fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,", "namely, S1 = {f1 }, to be final. This gives (4).\n\nLet us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].\n\nTo conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one i", "nitial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.\n\nState Complexity of Multiple Concatenation\n\n7\n\nProposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)", "U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input sy", "mbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .\n\nExample 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an u", "pper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .\n\n4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .\n\n8\n\nJ", ". Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).\n\nConstruct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).\n\nLet us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0,", "holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.\n\nState Complexity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1.\naj 1\n\nCase 3: 2 j n1 1. Then we have (s1 , S)", "1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n...\n\na1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N", "recognizing the language L(A 1 )L(A 2 ).\n\nAs shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }.\n\nNext, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G. Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.\n\nWe use the ideas from the above example to describe witnesses for multiple concatenatio", "n over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-", "letter alphabet {b, a1 , a2 , . . . , ak }.\n\nFirst, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in what follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA", "for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.\n\nState Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1 , b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n...\n\nni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n...\n\nai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).\n\nProof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si", "}) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .\n\nBy induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, re", "spectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).\n\nNow, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.\n\n12\n\nJ. Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with", "n1 = 3, n2 = 4, and n3 = 3.\n\nTheorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j, , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3", "}, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).\n\nState Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } wh", "ich\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to", "itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na", "a\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automat", "a have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G. Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },", "if i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n...\n\nai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\ {ai , b}\nai , b\n\n...\n\nai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n...\n\nak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).\n\n each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni )", "on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.\n\nState Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1", ")L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the l", "emma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an exam", "ple, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.\n\n5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for mult", "iple concatenation over a kletter alphabet. Let us start with the following example.\n\n16\n\nJ. Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1 , a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(", "A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.\n\nState Complexity of Multiple Concatenation\n\n17\n\nExample 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n...\n\na\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.\n\nFirst, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfro", "m the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\na", "n upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.\n\n18\n\nJ. Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from", "(f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na\n\nbn2\n\nCase 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons", "{q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in", "this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.\n\nState Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in", "what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ,", ", si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb\n\nAk\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n...\n\nak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding t", "he transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.\n\n20\n\nJ. Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N", ").\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .", "Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two disti", "nct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )\n\n(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult. Othe", "rwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, Ti+1\n, . . . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.\n\nState Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 t", "o si+1 . Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . . , Tk ).\n\nFinally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states w", "hich differ in sk .\n\nSince the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.\n\nWe conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bo", "und for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a per", "mutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.\n\n22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\", "{f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the th", "ird component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .\n\n(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the", "state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.\n\nNotice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to co", "ver such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .\n\nand the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the", "contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p =", "(f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has\n\n24\n\nJ. Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings", "over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.\n\nWe now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a", "in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each sta", "te (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n...\n\na, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).\n\nState Complexity of Multiple Concatenation\n\n25\n\na, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenat", "ion.\n\na, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\n26\n\nJ. Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}", "where q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .\n\nOur next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2", "n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.\n\n7. Unary Languages\nThe upper bo", "und on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntra", "nsitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.\n\nState Complexity of Multiple Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\nLemma 21", ". Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.\n\nLet f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is n", "ot representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is tight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf a", "m L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ. Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d", "d g(\n\nnk\nn1 n2\n, , . . . , ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and", "only if\nd f (\n\nn1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.\n\nBy [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.\n\nState Complexity of Multiple Concatenation\n\n29\n\nCorollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language", "recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .\n\nIn the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the lea", "st common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes", "(m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1,", "n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all", "i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is ac", "hieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.\n\nMotivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let", "Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/", "i I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.\n\nThe above example shows that our upper bound given by Theorem 25 is met", "by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and theref", "ore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concate", "nation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.\n\n32\n\nJ. Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met", "by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where", "exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound remains open."]}
{"method": "sliding", "num_chunks": 187, "avg_chunk_len": 797.3850267379679, "std_chunk_len": 28.265195437633672, "max_chunk_len": 800, "min_chunk_len": 412, "total_chars": 149111, "compression_ratio": 0.5017336078491862, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025\n\narXiv:2511.03814v1 [cs.FL] 5 Nov 2025\n\nSTATE COMPLEXITY OF MULTIPLE CONCATENATION\n\nJozef Jir sek\n(A)\n\n(A,B)\n\nGalina Jir skov \n\n(C,D)\n\nInstitute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk\n\n(C)\n\nMathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automa", "lovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple con", "ta. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.\n\nKeywords: regular languages, multiple concatenation, state complexity\n\n1. Introduction\nGiven formal languages L1 , L2 , . .", "catenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.\n\nKeywords: regular languages, multiple concatenation, state complexity\n\n1. Introduction\nGiven formal languages L1 , L2 , . . . , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic", ". , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.\n\nJozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ. Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov", "finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.\n\nJozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ. Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for t", "[5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s univer", "he concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe", "sal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concat", "witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used", "enation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain", "for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, an", "exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .\n\nState Complexity of Multiple Concatenation\n\n3\n\nFor a fi", "d provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .\n\nState Complexity of Multiple Concatenation\n\n3\n\nFor a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of state", "nite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be comple", "s, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1", "te; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states", ", and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. Th", "p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w i", "e\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NF", "n Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R =", "A. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ. Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following", "(Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ. Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final state", "two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .\n\nCorollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple", "s F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .\n\nCorollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assum", "Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of", "e that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 ,", "Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 , . . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , S", ". . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the n", "k ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition.\n\nState Complexity of Multiple Concatenation\n\n5\n\nDefinition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the n", "ext definition.\n\nState Complexity of Multiple Concatenation\n\n5\n\nDefinition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).\n\nNotice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs", "umber\nof valid states in the subset automaton D(N ).\n\nNotice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of", "A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .\n4\n\nProof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand", "states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .\n4\n\nProof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality.\n\nWe now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1", "s3 \n/ S3 is not valid, which gives the right inequality.\n\nWe now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.\n\nTheorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accept", ", . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.\n\nTheorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G. Jir skov \n\nand for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ).\n\n(2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 .\n\n(4)\n\nProof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).\n\nLet fi 1 \n/ Si 1\n. Then we ha", "ing L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G. Jir skov \n\nand for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ).\n\n(2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 .\n\n(4)\n\nProof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).\n\nLet fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).\n\nLet fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,", "ve just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).\n\nLet fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).\n\nLet us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3", "namely, S1 = {f1 }, to be final. This gives (4).\n\nLet us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].\n\nTo conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one i", "+ 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].\n\nTo conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi .", "nitial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.\n\nState Complexity of Multiple Concatenation\n\n7\n\nProposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)", "The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.\n\nState Complexity of Multiple Concatenation\n\n7\n\nProposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equ", "U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input sy", "ivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of", "mbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .\n\nExample 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an u", "valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .\n\nExample 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .\n\n4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 27", "pper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .\n\n4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .\n\n8\n\nJ", "1].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .\n\n8\n\nJ. Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).\n\nConstruct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-fi", ". Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).\n\nConstruct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).\n\nLet us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0,", "nal and state s2 non-initial. The NFA N is shown in Figure 2.\na2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).\n\nLet us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.\n\nState Comple", "holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.\n\nState Complexity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1.\naj 1\n\nCase 3: 2 j n1 1. Then we have (s1 , S)", "xity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1.\naj 1\n\nCase 3: 2 j n1 1. Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishabili", "1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n...\n\na1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N", "ty, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n...\n\na1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ).\n\nAs shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }.\n\nNext, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1", "recognizing the language L(A 1 )L(A 2 ).\n\nAs shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }.\n\nNext, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G. Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.\n\nWe use the ideas from the above example to describe witnesses for multiple concatenatio", "1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G. Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.\n\nWe use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbo", "n over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-", "l aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , . . . , ak }.\n\nFirst, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in wh", "letter alphabet {b, a1 , a2 , . . . , ak }.\n\nFirst, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in what follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA", "at follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.\n\nState Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1", "for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.\n\nState Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1 , b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n...\n\nni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n...\n\nai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).\n\nProof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si", ", b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n...\n\nni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n...\n\nai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).\n\nProof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S )", "}) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .\n\nBy induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, re", "(si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .\n\nBy induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).\n\nNow, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk", "spectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).\n\nNow, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.\n\n12\n\nJ. Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with", "1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.\n\n12\n\nJ. Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3.\n\nTheorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j", "n1 = 3, n2 = 4, and n3 = 3.\n\nTheorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j, , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3", ", , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3 }, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we", "}, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).\n\nState Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } wh", "have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).\n\nState Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the", "ich\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to", "string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1", "itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na", ". Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na\n\na\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N", "a\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automat", ", the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and", "a have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G. Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },", "i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G. Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n...\n\nai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\", "if i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n...\n\nai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\ {ai , b}\nai , b\n\n...\n\nai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n...\n\nak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).\n\n each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni )", "{ai , b}\nai , b\n\n...\n\nai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n...\n\nak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).\n\n each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.\n\nState Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add", "on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.\n\nState Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1", "the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a", ")L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the l", "valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) b", "emma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an exam", "y inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis", "ple, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.\n\n5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for mult", "reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.\n\n5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example.\n\n16\n\nJ. Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1", "iple concatenation over a kletter alphabet. Let us start with the following example.\n\n16\n\nJ. Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1 , a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(", ", a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.\n\nState Complexity of Multiple Concatenation\n\n17\n\nExample 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n...\n\na\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 1\n\na,", "A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.\n\nState Complexity of Multiple Concatenation\n\n17\n\nExample 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n...\n\na\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.\n\nFirst, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfro", "b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.\n\nFirst, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S", "m the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\na", "\\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\nan upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each val", "n upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.\n\n18\n\nJ. Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from", "id state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.\n\n18\n\nJ. Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na\n\nbn2\n\nCase 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state i", "(f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na\n\nbn2\n\nCase 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons", "s considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in", "{q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in", "s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 i", "this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.\n\nState Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in", "n its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.\n\nState Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the s", "what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ,", "ame as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb", ", si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb\n\nAk\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n...\n\nak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding t", "Ak\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n...\n\nak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 1", "he transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.\n\n20\n\nJ. Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N", "4. The proof of distinguishability is not for free this time.\n\n20\n\nJ. Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N ).\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same", ").\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .", "as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .\nNext, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbo", "Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two disti", "l ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two distinct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string", "nct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )\n\n(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult. Othe", "w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )\n\n(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult. Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 },", "rwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, Ti+1\n, . . . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.\n\nState Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 t", "{s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, Ti+1\n, . . . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.\n\nState Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 . Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . . , Tk ).\n\nFinally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then t", "o si+1 . Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . . , Tk ).\n\nFinally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states w", "he string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .\n\nSince the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.\n\nWe conjecture that k symbols are necessary for describing witnesses for concatenation of k la", "hich differ in sk .\n\nSince the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.\n\nWe conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bo", "nguages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to", "und for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a per", "show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it", "mutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.\n\n22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\", "is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.\n\n22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\ns", "{f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the th", "o f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .\n\n(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f", "ird component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .\n\n(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the", "2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a", "state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.\n\nNotice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to co", "is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.\n\nNotice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12:", "ver such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .\n\nand the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the", "Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .\n\nand the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.\n\nConstruct an NFA N for L(A", "contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p =", "1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has\n\n24\n\nJ. Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenatio", "(f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has\n\n24\n\nJ. Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings", "n on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs", "over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.\n\nWe now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a", "2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.\n\nWe now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 )", "in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each sta", ", (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each state (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n...\n\na, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).\n\nState Complexity of Multiple Concatenation\n\n25", "te (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n...\n\na, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).\n\nState Complexity of Multiple Concatenation\n\n25\n\na, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenat", "a, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation.\n\na, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\n26\n\nJ. Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+", "ion.\n\na, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\n26\n\nJ. Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}", "+nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .\n\nOur next result shows that a trivial upper bound n1 2n2 +n", "where q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .\n\nOur next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2", "3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N )", "n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.\n\n7. Unary Languages\nThe upper bo", "has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.\n\n7. Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our", "und on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntra", "study by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.\n\nState Complexity of Multiple", "nsitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.\n\nState Complexity of Multiple Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\nLemma 21", "Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\nLemma 21. Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that ea", ". Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.\n\nLet f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is n", "ch ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.\n\nLet f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is t", "ot representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is tight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf a", "ight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ. Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follow", "m L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ. Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d", "s from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(\n\nnk\nn1 n2\n, , . . . , ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A wi", "d g(\n\nnk\nn1 n2\n, , . . . , ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and", "th a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and only if\nd f (\n\nn1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.\n\nBy [3, Proposition 2.2], if n1 n2", "only if\nd f (\n\nn1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.\n\nBy [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.\n\nState Complexity of Multiple Concatenation\n\n29\n\nCorollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language", "nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.\n\nState Complexity of Multiple Concatenation\n\n29\n\nCorollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation", "recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .\n\nIn the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the lea", "of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .\n\nIn the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenatio", "st common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes", "n requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not b", "(m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1,", "y two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexit", "n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all", "y of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding", "i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is ac", "concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.\n\nMotivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the lengt", "hieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.\n\nMotivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let", "h of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof.", "Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/", "Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21},", "i I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.\n\nThe above example shows that our upper bound given by Theorem 25 is met", "and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.\n\nThe above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe i", "by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and theref", "dentity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for", "ore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concate", "the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 ,", "nation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.\n\n32\n\nJ. Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met", "n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.\n\n32\n\nJ. Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witne", "by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where", "sses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound", "exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound remains open."]}
{"method": "sentence", "num_chunks": 515, "avg_chunk_len": 144.21941747572816, "std_chunk_len": 128.50138608164266, "max_chunk_len": 818, "min_chunk_len": 8, "total_chars": 74273, "compression_ratio": 1.0072839389818642, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025\n\narXiv:2511. 03814v1 [cs. FL] 5 Nov 2025\n\nSTATE COMPLEXITY OF MULTIPLE CONCATENATION\n\nJozef Jir sek\n(A)\n\n(A,B)\n\nGalina Jir skov \n\n(C,D)\n\nInstitute of Computer Science, P.", "J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef. jirasek@upjs.", "sk\n\n(C)\n\nMathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske. sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata.", "Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al. [2018, Fundam.", "Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal.", "We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails. Keywords: regular languages, multiple concatenation, state complexity\n\n1.", "Introduction\nGiven formal languages L1 , L2 , . . .", ", Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . .", ", k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton. A preliminary version of this paper appeared in Proc.", "DCFS 2020, LNCS vol. 12442, pp. 78 90.", "(B) Research supported by VEGA grant 1/0350/22. (D) Research supported by VEGA grant 2/0096/23. Jozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ.", "Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 .", "In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state. The concatenation of three and four regular languages was considered by sik et\nal.", "[2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4]. Caron et al.", "[1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages. In this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages.", "We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . .", ". , Ak are defined over the alphabet {b, a1 , . .", ". , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata.", "These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states.", "With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al.", "[1]. In the case of k = 3, we show that the ternary alphabet is optimal. We also examine multiple concatenation on binary, ternary, and unary languages.", "We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , . . .", ", nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.", "2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].", "The size of a finite set S is denoted by |S|, and the set of all its subsets by 2S . State Complexity of Multiple Concatenation\n\n3\n\nFor a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ .", "The multiple concatenation of k languages L1 , L2 , . . .", ", Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . .", ", uk Lk }. A deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ .", "The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }. All deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function. We usually omit , and write qa instead of q a.", "Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . .", ". , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , .", ". . , q ) the transformation that maps qi to qi+1 for i = 1, .", ". . , 1, the\nstate q to q1 , and fixes any other state in Q.", "In particular, (q1 ) denotes the identity. Next, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . .", ". , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.", "A state q Q is reachable in the DFA A if there is a string w Σ such that q = sw. Two states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .", "A DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , .", ". . , nk ) 7 max{sc(f (L1 , L2 , .", ". . , Lk )) | sc(Li ) ni for i = 1, 2, .", ". . , k}.", "A nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . .", ". , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . .", ". , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }.", "For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a. Let N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}.", "The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ). The reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ.", "Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions. A subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .", "We use the following two simple observations to prove distinguishability of states\nin subset automata. Lemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions.", "Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ). Proof.", "Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .", "Corollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. 3.", "Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.", "For i = 1, 2, . . .", ", k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . .", ". , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . .", ". , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . .", ". , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . .", ". , k 1; the initial state of N is s1 , and its set of final states is Fk . Since A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, .", ". . , k.", "We represent such a set by the k-tuple ({q}, S2 , S3 , . . .", ", Sk ), or\nmore often by (q, S2 , S3 , . . .", ", Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , .", ". . , Sk ) or (q, S2 a, S3 , .", ". . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .", "It follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . .", ", Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition. State Complexity of Multiple Concatenation\n\n5\n\nDefinition 3.", "A state (S1 , S2 , . . .", ", Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 . Since each reachable state of D(N ) is valid, we have the next observation. Proposition 4.", "An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ). Notice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi .", "If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , . . .", ", Ak as follows: for each i = 1, 2, . . .", ", k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk . For k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.", "Proposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .", "4\n\nProof. Every state (S1 , S2 , . .", ". , Sk ) with si Si for i = 2, 3, . .", ". , k is a valid state. This\ngives the left inequality.", "On the other hand, every state (S1 , S2 , . . .", ", Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality. We now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , .", ". . , Sk ) such that for fixed S1 , S2 , .", ". . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , .", ". . , Si 1 , Si , Si+1 , .", ". . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1 , .", ". . , Sk ) such that for a fixed S1 , S2 , .", ". . , Si 1\n\nwith fi 1 Si 1 the state (S1 , .", ". . , Si 1 , Si , Si+1 , .", ". . , Sk ) is valid.", "Then we have the next result. Theorem 6. Let k 2, ni 2 for i = 1, 2, .", ". . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi .", "Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ). Then\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G.", "Jir skov \n\nand for i = 2, 3, . . .", ", k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ). (2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 . (4)\n\nProof.", "If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).", "Let fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . .", ". , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).", "Let fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si .", "This gives (3). Finally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).", "Let us illustrate the above result in the following example. Example 7. Let k = 3 and n1 , n2 , n3 2.", "Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3. 6]. To conclude this section, let us consider also the case when some automata have just\none state.", "If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above.", "Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . .", ". , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }.", "If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state. State Complexity of Multiple Concatenation\n\n7\n\nProposition 8.", "Let k 2, j {1, 2, . . .", ", k}, nj = 1, and ni 2 if i = j. For i = 1, 2, . .", ". , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3).", "Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1. Proof. First, let j = 1.", "Then we have S1 = {f1 } in each valid state (S1 , S2 , . . .", ", Sk ). It follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 . Now, let j = k.", "Then all states (S1 , S2 , . . .", ", Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.", "Finally, let 2 j k 1. Then all states (S1 , S2 , . .", ". , Si 1 , {fi }, {si+1 }, , , . .", ". , )\nare equivalent to the state ({s1 }, {s2 }, . .", ". , {si 1 }, {fi }, {si+1 }, , , . .", ". , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , .", ". . , Si 1 , , , .", ". . , ) or of the\nform ({s1 }, {s2 }, .", ". . , {si 1 }, {fi }, Si+1 , Si+2 , .", ". . , Sk ).", "If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 . Example 9.", "Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 .", "This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ . 4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp.", "266 271]. We use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.", "Example 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1.", "The symbol a1 performs the circular shift in A1 , and the identity in A2 . Symmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 . 8\n\nJ.", "Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n. .", ". a1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n. .", ". a2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ). Construct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial.", "The NFA N is shown in Figure 2. a2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n. .", ". a1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n. .", ". a2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ). Let us show that each valid state (j, S) is reachable in the subset automaton D(N ).", "The proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.", "There are three cases to consider. Case 1: j = f1 . Then s2 S since (f1 , S) is valid.", "Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction. State Complexity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S.", "Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1. aj 1\n\nCase 3: 2 j n1 1.", "Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2. Thus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 .", "It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state. To guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.", "a2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n. . .", "a1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n. . .", "a2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ). As shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N .", "In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }. Next, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G.", "Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.", "We use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . .", ". , k. Let Σ = {b, a1 , a2 , .", ". . , ak } be an alphabet consisting of k + 1\nsymbols.", "Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . .", ", ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . .", ", ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}. Σ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n.", ". . ai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , .", ". . , ak }.", "First, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial. The next observation is crucial in what follows.", "It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }). Moreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.", "Lemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.", "State Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1 , b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n. . .", "ni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n. . .", "ai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i). Proof. The proof of both (i) and (ii) is by induction on |S|.", "The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n. i\nLet |S| 2.", "Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n.", "Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S . By induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).", "Now, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . .", ", Ak as follows: First, for each i = 1, 2, . . .", ", k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . .", ". , fk 1 non-final, and states s2 , s3 , . .", ". , sk non-initial; see Figure 6 for\nan illustration. 12\n\nJ.", "Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3. Theorem 12.", "Let k 2 and ni 3 for i = 1, 2 . . .", ", k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.", "Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ). Proof. We first prove reachability.", "Let q = (j, S2 , S3 , . . .", ", Sk ) be a valid state. If S2 = , then the state q = (j, , , . .", ". , ) is reached from the initial\nstate (s1 , , , . .", ". , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.", "Then q = (j, S2 , S3 , . . .", ", S , , , . . .", ", ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . .", ", . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . .", ". , ) to\n(s1 , {s2 }, {s3 }, . .", ". , {s 1 }, {s }, , , . .", ". , ). Now, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , .", ". . , and ending with S3 and S2 .", "By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ). Moreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , .", ". . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, .", ". . , {s 1 }, {s }, , .", ". . , ) \n(s1 , {s2 }, .", ". . , {s 1 }, S , , .", ". . , ).", "State Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . .", ". , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . .", ". , {s 2 }, {s 1 }, S , , . .", ". , ) (s1 , {s2 }, . .", ". , {s 2 }, S 1 , S , , . .", ". , ). Now, for i = 2, 3, .", ". . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ).", "Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , .", ". . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , .", ". . , A .", "Set W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . .", ". , {s 2 }, S 1 , S , , . .", ". , ) (s1 , S2 , . .", ". , S 2 , S 1 , S , , . .", ". , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , .", ". . , S , , , .", ". . , ) is reached from the initial state (s1 , , , .", ". . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .", "To get distinguishability, let us show that each singleton set is co-reachable in N . First, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na\n\na\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . .", ". , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, .", ". . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.", "Thus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. Notice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states.", "We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability.", "To this aim, let k 2, ni 2 for i = 1, 2, . . .", ", k,\nand Σ = {b, a1 , a2 , . . .", ", ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G.", "Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others. Consider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . .", ". , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . .", ". , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . .", ". , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . .", ". , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n. .", ". ai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\ {ai , b}\nai , b\n\n. .", ". ai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n. .", ". ak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom). each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.", "State Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . .", ", Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . .", ", k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk . Theorem 13.", "Let k 2 and ni 2 for i = 1, 2, . . .", ", k. Let A1 , A2 , . .", ". , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).", "Proof. First, notice that Lemma 11 still holds for automata A1 , A2 , . .", ". , Ak 1 since\nthe transitions on a1 , a2 , . .", ". , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.", "Let ({j}, S2 , S3 , . . .", ", Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . .", ". , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12. Now, let Sk = .", "Then the state (s1 , {s2 }, {s3 }, . . .", ", {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ).", "However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components. Let u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak .", "Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . .", ", {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . .", ", {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . .", ", Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 . To prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b. Finally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i .", "It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable. 5.", "Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example. 16\n\nJ.", "Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1 , a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2. State Complexity of Multiple Concatenation\n\n17\n\nExample 14.", "Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9. Let us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages. b\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n.", ". . a\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n.", ". . a, b\n\nn2 1\n\na, b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.", "First, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.", "Now, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final.", "Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|.", "The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.", "Then abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N .", "By Proposition 8,\nan upper bound is V2 = 2n2 1 . Finally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial.", "Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 .", "Let |S| 1. There are three cases to consider. 18\n\nJ.", "Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid.", "We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction. Case 2: j = s1 . Case 2.", "a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1. a\n\nbn2\n\nCase 2.", "b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1. Case 2.", "c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }. m 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.", "a. Case 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.", "This proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.", "Case 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N . Case 2: S = T and i < j.", "First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1.", "Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.", "First, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A. It follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings. Now, let s2 an1 = s2 .", "Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component. Finally, let s2 an1 = s2 .", "Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component. This proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.", "State Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states). Therefore, in what follows we assume that k 3. We use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , .", ". . , ak 1 }.", "The idea is as follows. The transitions on input symbols a1 , a2 , . .", ". , ak 1 in automata A1 , A2 , . .", ". , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, .", ". . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.", "To this aim, let k 3 and Σ = {b, a1 , a2 , . . .", ", ak 1 } be a k-letter alphabet. Let n1 , nk 2 and ni 3 for i = 2, 3, . .", ". , k 1. For i = 1, 2, .", ". . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, .", ". . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, .", ". . , ni ), b : ({2, 3, .", ". . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, .", ". . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.", "b\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n. . .", "ai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb\n\nAk\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n. . .", "ak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . .", ", k 1. Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . .", ". , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . .", ". , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ).", "The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time. 20\n\nJ.", "Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, .", ". . , k 1.", "Let A1 , A2 , . . .", ", Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . .", ", ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all valid states are reachable and pairwise distinguishable in D(N ).", "Proof. Consider a valid state q = (j, S2 , . .", ". , Sk 1 , Sk ). First, let Sk = .", "Since the\ntransitions on a1 , a2 , . . .", ", ak 1 in A1 , A2 , . . .", ", Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . .", ", Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem. Now let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14.", "As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . .", ". , sk 2 , we reach (s1 , {s2 }, {s3 }, . .", ". , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS . Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ).", "Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 .", "Then the\nstate (s1 , {s2 }, {s3 }, . . .", ", {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . .", ", {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 . To get distinguishability, let p = (S1 , S2 , S3 , .", ". . , Sk ) and q = (T1 , T2 , T3 , .", ". . , Tk )\nbe two distinct valid states.", "If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 . Let Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . .", ". , k. Let us show that there is a string that sends p and q to two states which differ in si+1 .", "Without loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . .", ". , Si 1\n, S (Si w), Si+1\n, . .", ". , Sk )\n\n(T1 , T2 , T3 , . .", ". , Ti 1\n, T (Ti w), Ti+1\n, . .", ". , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult.", "Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . .", ", Si and all T1 , T2 , . . .", ", Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 }, {s3 }, .", ". . , {si 1 }, S {fi }, Si+1\n, .", ". . , Sk )\n\n({s1 }, {s2 }, {s3 }, .", ". . , {si 1 },\n\n{si }\n\n, Ti+1\n, .", ". . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, .", ". . , k 1.", "There are two cases to consider. State Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 .", "Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . .", ", {si 1 }, S {fi }, {si+1 }, Si+2\n, . . .", ", Sk )\n\n({s1 }, {s2 }, {s3 }, . . .", ", {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . .", ", Tk ). Finally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 . Case 2: i = k 1.", "Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . .", ", k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . .", ". , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . .", ". , {sk 2 }, {sk 1 }, {sk }). k\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .", "Since the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result. Corollary 16. The DFAs A1 , A2 , .", ". . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.", "We conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3. Theorem 17.", "The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal. Proof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3.", "Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . .", ", ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . .", ", Ak 1 must\nhave one final state, and it must be different from the initial state. Construct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.", "Notice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 . If both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them. If both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.", "22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .", "Next, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a.", "Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 .", "Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11.", "Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 . Next, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 .", "It follows that b is a permutation on Q3 . Hence both a and b perform permutations on Q3 , thus resulting in a contradiction. b\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .", "(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig.", "12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b.", "Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 . This means that s3 b = s3 . Hence b is a permutation on Q3 .", "Let r Q2 \\ {s2 b, f2 }. Then the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 .", "Thus both a and b perform a permutation\nin A2 , which is a contradiction. Notice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states.", "Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case. Let Σ = {b, c, a2 , a3 , .", ". . ak 1 } be a k-letter alphabet.", "For i = 1, 2, . . .", ", k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 . and the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . .", ". , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . .", ". , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise. c\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6.", "In each DFA, the remaining symbols perform identities. Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . .", ". , Ak as\nfollows: for each i = 1, 2, . .", ". , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk . We prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , .", ". . , Tk ) from a state q = (s1 , S2 , S3 , .", ". . , Sk ), the symbol b has\n\n24\n\nJ.", "Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }.", "Then, we have to carefully return {si } back to Si . 6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages.", "Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . .", ", nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example. Example 18.", "Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end. Let us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|.", "The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).", "Set S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.", "We now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end. Theorem 19.", "Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . .", ", k. Let A1 , A2 , . .", ". , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.", "Proof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . .", ". , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . .", ". , k 1 and σ {a, b}, by making states f1 , f2 , . .", ". , fk 1 non-final, and\nstates s2 , s3 , . .", ". , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them.", "Let N be the resulting NFA;\nsee Figure 16 for an illustration. In the subset automaton D(N ), each state (j, , , . .", ". , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . .", ". , ) by bj 1 , and (f1 , {s2 }, , , . .", ". , ) is\nreached from (f1 1, , , . .", ". , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n.", ". . a, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).", "State Complexity of Multiple Concatenation\n\n25\n\na, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n. . .", "a, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n. . .", "a, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n. . .", "a, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . .", ", k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation. a, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5. 26\n\nJ.", "Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , .", ". . , Sk ) with S2 {2, 3, .", ". . , n2 2},\nSi {1, 2, .", ". . , ni 2} for i = 3, 4, .", ". . , k 1, and Sk {1, 2, .", ". . , nk 1} is reachable.", "This gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states. Moreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , .", ". . , Sk )\nand (j, T2 , T3 , .", ". . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 .", "Next, the states (i, S2 , S3 , . . .", ", Sk ) and (j, S2 , S3 , . . .", ", Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j . Our next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.", "Theorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . .", ". , k. There\nexist ternary DFAs A1 , A2 , .", ". . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states.", "Proof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . .", ". , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration.", "As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . .", ", Sk ). Each such state is sent to the state (j, S2 , S3 , . .", ". , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c .", "By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound. 7.", "Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5. 4 and 5. 5].", "This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic.", "In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails. Recall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , .", ". . , q 1 and a cycle p0 , p1 , .", ". . , pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf.", "[6]. Let n1 , n2 , . .", ". , nk be positive integers with gcd(n1 , n2 , . .", ". , nk ) = 1. Then g(n1 , n2 , .", ". . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , .", ". . , xk .", "Let us star with the following observation. State Complexity of Multiple Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5. Lemma 21.", "Let n1 , n2 , . . .", ", nk be positive integers with gcd(n1 , n2 , . . .", ", nk ) = d. Then each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . .", ". , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , .", ". . , xk 0, is d g( nd1 , nd2 , .", ". . , ndk ).", "Proof. The first claim follows from the fact that each ni is a multiple of d. Since gcd( nd1 , nd2 , .", ". . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , .", ". . , xk 0, is g( nd1 , nd2 , .", ". . , ndk ).", "Multiplying by d, we get the second claim. Let f (n1 , n2 , . .", ". , nk ) = g(n1 , n2 , . .", ". , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result.", "Theorem 22. Let A1 , A2 , . .", ". , Ak be unary cyclic automata with n1 , n2 , . .", ". , nk\nstates, respectively. Let d = gcd(n1 , n2 , .", ". . , nk ).", "Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . .", ", ndk ) k + 1,\nand this upper bound is tight. Proof. Denote Li = L(Ai ) and L = L1 L2 Lk .", "We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . .", ". , ndk ) k + 1, we have am L if and only if am+d L. We can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf.", "[6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . .", ". , ndk ) k + 1. If am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ.", "Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , .", ". . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , .", ". . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , .", ". . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , .", ". . , ) + 1.", "d d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . .", ", x k 0. Therefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L. Conversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0.", "Since m d f ( nd1 , nd2 , . . .", ", ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(\n\nnk\nn1 n2\n, , . . .", ", ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . .", ", x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L. To get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata.", "Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . .", ". , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , .", ". . , xk 0.", "Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,. .", ". , d ) k+ d is in L if and only if\nd f (\n\nn1 n2\nnk\n, , . .", ". , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . .", ". , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . .", ". , ) + d = x1 n1 + x2 n2 + + xk nk . d d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,.", ". . , d ) k \n/ L, while ad f ( d , d ,.", ". . , d ) k+d L.", "Hence A is minimal. By [3, Proposition 2. 2], if n1 n2 nk , then g(n1 , n2 , .", ". . , nk ) n1 nk .", "This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . .", ", nk ). The result of the\nprevious theorem can be generalized as follows. State Complexity of Multiple Concatenation\n\n29\n\nCorollary 23.", "For i = 1, 2, . . .", ", Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . .", ". , λk ). Then the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , .", ". . , λdk ) k + 1, and this upper bound is\ntight.", "Proof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf.", "[6, Theorem 6]. The upper bound is met by languages Li = a i +λi 1 (aλi ) . In the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11].", "The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively. Example 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1.", "If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j). As shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.", "Nevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other. Our next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.", "In such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1. By [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1. In both cases, the resulting complexity is at most (m i)(n j) + i + j.", "Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j.", "The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3. If follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}. Assume that in all of this cases, we have gcd(m i, n j) 3.", "Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1. 3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.", "Moreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails. Motivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails.", "While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.", "Theorem 25. For i = 1, 2, . .", ". , k, let Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , .", ". . , i } {1, 2, .", ". . , k}, let\ndI = gcd(λi1 , λi2 , .", ". . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , .", ". . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0.", "Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . .", ", λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . .", ", k}}. Proof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ).", "We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi . I {1,2,.", ". . ,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).", "The concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4].", "Example 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}. We have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.", "The size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}. The above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.", "8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , .", ". . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , .", ". . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction.", "Using symbols a1 , a2 , . . .", ", ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states.", "Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states. Then we provided special binary witnesses for the concatenation of two languages. Using our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet.", "This solves an open problem stated in [1]. For k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].", "We also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . .", ". , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages. 32\n\nJ.", "Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.", "4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails. Some problems remain open.", "First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . .", ", k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.", "We proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?", "Next, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ? Finally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.", "The tightness of this upper bound remains open."]}
{"method": "paragraph", "num_chunks": 767, "avg_chunk_len": 95.50586701434159, "std_chunk_len": 326.1076555824217, "max_chunk_len": 3326, "min_chunk_len": 1, "total_chars": 73253, "compression_ratio": 1.0213097074522546, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025", "arXiv:2511.03814v1 [cs.FL] 5 Nov 2025", "STATE COMPLEXITY OF MULTIPLE CONCATENATION", "Jozef Jir sek\n(A)", "(A,B)", "Galina Jir skov", "(C,D)", "Institute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk", "(C)", "Mathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk", "ABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.", "Keywords: regular languages, multiple concatenation, state complexity", "1. Introduction\nGiven formal languages L1 , L2 , . . . , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.", "Jozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197", "2", "J. Jir sek, G. Jir skov", "The first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .", "State Complexity of Multiple Concatenation", "3", "For a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by", "4", "J. Jir sek, G. Jir skov", "swapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .", "Corollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 , . . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition.", "State Complexity of Multiple Concatenation", "5", "Definition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).", "Notice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1", "n1 2n2 +n3 + +nk #τk", "3\nn1 2n2 +n3 + +nk .\n4", "Proof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality.", "We now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let", "Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1", "with fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,", "Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1", "with fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.", "Theorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,", "(1)", "6", "J. Jir sek, G. Jir skov", "and for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2", "Vi = 2", "(Ui+1 + Vi+1 ).", "(2)\n(3)", "Finally, we have\n#τk = (n1 1)U2 + V2 .", "(4)", "Proof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).", "Let fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).", "Let fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).", "Let us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].", "To conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.", "State Complexity of Multiple Concatenation", "7", "Proposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then", "V2 ,\nif j = 1;", "n1 ,\nif j = k = 2;", "(n 1)U + V + 1\n1\n2\n2\nsc(L)", "with\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1", "(n1 1)U2 + V2 + Vi+1", "with Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .", "Example 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .", "4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .", "8", "J. Jir sek, G. Jir skov \na2", "A1", "a2", "s1 =1", "a1", "2", "a2", "a2\na1", "...", "a1", "n1 1", "a1", "f1 =n1", "a1\na1", "A2", "s2 =1", "a1\na2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).", "Construct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2", "N", "a2", "s1 =1", "a1", "2", "a2\na1", "...", "a1", "n1 1", "a2\na1", "f1 =n1", "a1\na1\na1", "s2 =1", "a2\na1", "a2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).", "Let us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.", "State Complexity of Multiple Concatenation", "9", "Case 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1", "a", "1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2", "where the leftmost state is reachable as shown in Case 1.\naj 1", "Case 3: 2 j n1 1. Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b", "a2", "N", "s1 =1", "a1 , b", "2", "a2 , b\na1", "...", "a1", "n1 1", "a2 , b\na1", "f1 =n1", "a1\na2 , b", "a1\na1 , b", "a1", "s2 =1", "a2 , b", "a2", "2", "a1 , b", "a1 , b", "...", "a2", "n2 1", "a2", "f2 =n2", "a2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ).", "As shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na", "a", "a", "a", "a", "2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2}", "{2} \n{s2 }.", "Next, since n1 3, we have\nb", "a", "a", "a", "a", "1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1}", "{2} \n{s1 };", "10", "J. Jir sek, G. Jir skov \nb", "notice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb", "have {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.", "We use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}", "Ai", "si =1", "Σ \\ {ai }\nai , b", "2", "Σ \\ {ai }", "Σ \\ {ai }\nai", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "Figure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , . . . , ak }.", "First, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in what follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw", "S\n(i) (si 1 , {si }) \n(si 1 , S);", "u", "(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.", "State Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }", "Ni", "si 1", "ai 1 , b", "Σ \\ {ai 1 }", "ai 1", "2", "11", "ai 1", "...", "ni 1 1", "Σ \\ {ai 1 }", "ai 1", "fi 1", "ai 1\nΣ \\ {ai }", "ai 1", "Σ \\ {ai , b}", "si", "Σ \\ {ai }", "ai , b", "ai", "2", "Σ \\ {ai }", "Σ \\ {ai }", "...", "ai", "ni 1", "ai", "fi", "ai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).", "Proof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na", "a", "a", "a", "i\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2})", "(si 1 , {ni 1}) \n(si 1 , {fi }),", "so, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn", "i 1\nai 1", "am 1", "i\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),", "where the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .", "By induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).", "Now, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.", "12", "J. Jir sek, G. Jir skov \na2 , a3", "N", "s1", "a2 , a3 , b\na1 , b", "2", "a2 , a3 , b\na1", "a1\na1\na1 , a3", "s2", "f1\na2 , a3 , b\na1 , a3 , b", "a2 , b", "2", "a1 , a3 , b\na2", "3", "a2", "a1 , a3 , b\na2", "a2\na1 , a2", "s3", "f2\na1 , a3 , b\na1 , a2 , b", "a1 , a2 , b\na3 , b", "2", "a3", "f3", "a3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3.", "Theorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j, , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3 }, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS", "(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).", "State Complexity of Multiple Concatenation", "13", "Next, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1", "(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW", "(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na", "a", "b", "a", "a", "a", "b", "a", "a", "3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},", "14", "J. Jir sek, G. Jir skov", "that is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }", "Ai (i I)", "si =1", "Σ \\ {ai , ak }", "ai , ak", "2", "ai , ak", "Σ \\ {ai , ak }", "...", "ai , ak", "ni 2", "Σ \\ {ai , ak }", "ai , ak", "fi =ni", "ak", "ai\nΣ \\ {ai , b}", "Ai (i J)", "si =1", "Σ \\ {ai , b}\nai , b", "2", "Σ \\ {ai , b}", "Σ \\ {ai , b}\nai , b", "...", "ai , b", "ni 2", "ai , b", "fi =ni", "b", "ai\nΣ \\ {ak , b}", "Ak", "sk =1", "Σ \\ {ak , b}", "ak , b", "2", "ak , b", "Σ \\ {ak , b}", "...", "ak , b", "nk 2", "Σ \\ {ak , b}", "ak , b", "fk =nk", "ak", "b\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).", "each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.", "State Complexity of Multiple Concatenation", "15", "Construct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb", "a", "a", "b", "a", "a", "a", "a", "b", "a", "a", "5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1", "{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.", "5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example.", "16", "J. Jir sek, G. Jir skov \na2 , a3 , a4 , b", "b", "A1", "s1", "a5", "2", "f1", "N", "a2 , a3 , a4 , b\na1 , a5", "s1", "a1 , a3 , a4 , a5", "s2", "a1 , a3 , a4 , a5 , b", "a2 , b\na1 , a2 , a4 , b", "s3", "2", "f3", "a1 , a2 , a4 , b\na3 , a5", "s3", "a1 , a2 , a3 , a5", "s4", "f4", "s4", "a4 , b", "s5", "f3", "a1 , a2 , a4 , a5 , b", "f4", "a1 , a2 , a3 , a4 , a5", "a1 , a2 , a3 , a4", "f5", "a3 , a5", "a1 , a2 , a3 , a5 , b", "a4 , b", "s5", "a1 , a2 , a4 , a5 , b", "a1 , a2 , a3 , a5 , b", "a4", "A5", "2\na3", "a3 , a5", "A4", "a2 , a3 , a4 , a5 , b", "f2", "a2", "A3", "f1", "a1 , a3 , a4 , a5 , b\na2 , b", "s2", "f2", "a1 , a5", "a1", "a1 , a5", "A2", "2", "a2 , a3 , a4 , a5 , b", "a5 , b", "f5", "b\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.", "State Complexity of Multiple Concatenation", "17", "Example 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb", "b", "b", "b\nb\nA", "s1 =1", "a", "a", "2", "3", "...", "a", "n1 1", "a", "f1 =n1", "a", "b", "B", "a", "s2 =1", "a", "a, b", "2", "3", "a, b", "...", "a, b", "n2 1", "a, b", "f2 =n2", "a, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.", "First, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na", "bm 2", "(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\nan upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.", "18", "J. Jir sek, G. Jir skov", "Case 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na", "(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na", "bn2", "Case 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1", "a", "(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1", "b", "an1 1", "(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.", "State Complexity of Multiple Concatenation", "19", "Hence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb", "b", "b\nb", "Ai\n(i<k)", "si =1", "ai", "2", "ai", "3", "sk =1", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "b", "Ak", "ai", "ak 1", "2", "ak 1 , b", "3", "ak 1 , b", "...", "ak 1 , b", "nk 1", "ak 1 , b", "fk =nk", "ak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.", "20", "J. Jir sek, G. Jir skov", "Theorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N ).\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .\nNext, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two distinct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states", "(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )", "(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )", "where S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of", "the resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired", "result. Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", Ti+1\n, . . . , Tk )", "where q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.", "State Complexity of Multiple Concatenation", "21", "Case 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 . Thus after reading ai+1 b, we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", {si+1 }, Ti+2\n, . . . , Tk ).", "Finally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .", "Since the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.", "We conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw", "w", "from the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw", "w", "then it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.", "22", "J. Jir sek, G. Jir skov", "Hence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2", "0", "p", "a", "q\nb", "f2", "Figure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .", "(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.", "Notice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,", "State Complexity of Multiple Concatenation", "23\nb", "A2", "p", "0", "q", "a", "b", "f2", "Figure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .", "and the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc", "c", "a2", "b\nA1", "s1", "f1", "A2", "s2", "c", "s3", "b\na3", "a4\nf3", "A4", "c", "c", "s4", "s5", "b\na5", "c\na4", "f4", "b", "b", "a5\nA5", "f2", "b", "b", "a3\nA3", "c\na2", "b\nc", "b", "b", "a5\nf5", "A6", "s6", "c\na5", "f6", "Figure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has", "24", "J. Jir sek, G. Jir skov", "to be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2", "a", "{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.", "We now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each state (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b", "N", "1", "a", "2", "a, b", "3", "a, b", "...", "a, b", "n 1", "a, b", "n", "Figure 14: A binary NFA N such that every set {1} S is reachable in D(N ).", "State Complexity of Multiple Concatenation", "25", "a, b", "a", "A1", "s1 =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "n1 2", "a, b", "n1 1", "b", "f1 =n1\na, b", "b", "A2", "a", "s2 =1", "a, b", "2", "3", "a, b", "...", "a, b", "n2 2", "a, b", "n2 1", "a, b", "f2 =n2\na, b", "Ai\n(i>2)", "si =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "ni 2", "a, b", "ni 1", "a, b", "fi =ni", "Figure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation.", "a, b\na\nN", "s1 =1", "a, b", "a, b", "b", "b", "s2 =1", "2", "a", "3", "b", "f1 =4\na, b", "a, b\n2", "a, b", "3", "a, b", "4", "a, b", "a, b", "2", "a, b", "3", "a, b", "f3 =4", "a, b", "a, b", "2", "a, b", "6", "5\na, b", "a, b\ns4 =1", "a, b", "a, b", "a, b\ns3 =1", "f2 =5", "3", "a, b", "f4 =4", "a, b", "5", "Figure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "26", "J. Jir sek, G. Jir skov", "all strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .", "Our next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.", "7. Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.", "State Complexity of Multiple Concatenation", "27\na, b", "c\na\nN", "s1 =1", "a, b\nc", "c", "b", "c", "s2 =1", "a", "c", "a, b\nc", "2\nb", "a, b", "2\nc", "s3 =1", "a, b", "s4 =1", "a, b", "c\na, b", "2", "b\nc", "f1 =4", "c", "a, b", "c", "a, b", "3", "a, b", "a, b", "3", "a, b", "a, b", "4", "f2 =5", "a, b", "a, b\nc", "6", "a, b", "c", "f3 =4", "a, b\nc", "f4 =4", "a, b", "5", "c", "c\n3", "c", "a, b", "c", "2", "c", "3", "c\na, b", "5", "a, b", "Figure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "Lemma 21. Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.", "Let f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is tight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi", "28", "J. Jir sek, G. Jir skov", "and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (", "n1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd", "n1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd", "d f(", "Since x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(", "nk\nn1 n2\n, , . . . , ) + 1,\nd d\nd", "and therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and only if\nd f (", "n1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd", "for some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(", "n1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1", "n2", "nk", "n1", "n2", "nk", "By Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.", "By [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.", "State Complexity of Multiple Concatenation", "29", "Corollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .", "In the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this", "30", "J. Jir sek, G. Jir skov", "number by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <", "2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3", "Now, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.", "Motivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/", "i I", "State Complexity of Multiple Concatenation", "31", "Q\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n(", "1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.", "The above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.", "32", "J. Jir sek, G. Jir skov", "Finally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound remains open."]}
{"method": "recursive", "num_chunks": 1023, "avg_chunk_len": 71.36265884652981, "std_chunk_len": 132.54199597684072, "max_chunk_len": 790, "min_chunk_len": 1, "total_chars": 73004, "compression_ratio": 1.0247931620185196, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025", "arXiv:2511.03814v1 [cs.FL] 5 Nov 2025", "STATE COMPLEXITY OF MULTIPLE CONCATENATION", "Jozef Jir sek\n(A)", "(A,B)", "Galina Jir skov", "(C,D)", "Institute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk", "(C)", "Mathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk", "ABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet.", "This solves an open problem stated by Caron et al. [2018, Fundam. Inform.", "160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case.", "Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.", "Keywords: regular languages, multiple concatenation, state complexity", "1. Introduction\nGiven formal languages L1 , L2 , . . . , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.", "Jozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197", "2", "J. Jir sek, G. Jir skov", "The first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al.", "[8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state. The concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found.", "The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4]. Caron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata.", "They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages. In this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1].", "Our witness\nautomata A1 , A2 , . . .", ", Ak are defined over the alphabet {b, a1 , . . .", ", ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation.", "The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata.", "Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1].", "In the case of k = 3, we show that the ternary alphabet is optimal. We also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , .", ". . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k.", "For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case. 2.", "Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7]. The size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .", "State Complexity of Multiple Concatenation", "3", "For a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , .", ". . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , .", ". . , uk Lk }.", "A deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.", "All deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function. We usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}.", "Each input symbol a induces a transformation on Q = {q1 , q2 , . . .", ", qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . .", ". , q ) the transformation that maps qi to qi+1 for i = 1, . .", ". , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.", "Next, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . .", ", 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state. A state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.", "Two states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ . A DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable.", "The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . .", ". , nk ) 7 max{sc(f (L1 , L2 , . .", ". , Lk )) | sc(Li ) ni for i = 1, 2, . .", ". , k}. A nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function.", "A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . .", ", qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . .", ", m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.", "Let N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ.", "The subset automaton D(N ) recognizes the language L(N ). The reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by", "4", "J. Jir sek, G. Jir skov", "swapping the roles of initial and final states, and by reversing all transitions. A subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R . We use the following two simple observations to prove distinguishability of states\nin subset automata.", "Lemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T .", "If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ). Proof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R .", "It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .", "Corollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. 3.", "Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.", "For i = 1, 2, . . .", ", k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . .", ". , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . .", ". , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . .", ". , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . .", ". , k 1; the initial state of N is s1 , and its set of final states is Fk . Since A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, .", ". . , k.", "We represent such a set by the k-tuple ({q}, S2 , S3 , . . .", ", Sk ), or\nmore often by (q, S2 , S3 , . . .", ", Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , .", ". . , Sk ) or (q, S2 a, S3 , .", ". . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .", "It follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . .", ", Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition.", "State Complexity of Multiple Concatenation", "5", "Definition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).", "Notice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , .", ". . , Ak as follows: for each i = 1, 2, .", ". . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .", "For k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities. Proposition 5.", "Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1", "n1 2n2 +n3 + +nk #τk", "3\nn1 2n2 +n3 + +nk .\n4", "Proof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality.", "We now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let", "Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1", "with fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,", "Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1", "with fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.", "Theorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,", "(1)", "6", "J. Jir sek, G. Jir skov", "and for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2", "Vi = 2", "(Ui+1 + Vi+1 ).", "(2)\n(3)", "Finally, we have\n#τk = (n1 1)U2 + V2 .", "(4)", "Proof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).", "Let fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).", "Let fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).", "Let us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].", "To conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.", "State Complexity of Multiple Concatenation", "7", "Proposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then", "V2 ,\nif j = 1;", "n1 ,\nif j = k = 2;", "(n 1)U + V + 1\n1\n2\n2\nsc(L)", "with\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1", "(n1 1)U2 + V2 + Vi+1", "with Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1. Proof. First, let j = 1.", "Then we have S1 = {f1 } in each valid state (S1 , S2 , . . .", ", Sk ). It follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 . Now, let j = k.", "Then all states (S1 , S2 , . . .", ", Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.", "Finally, let 2 j k 1. Then all states (S1 , S2 , . .", ". , Si 1 , {fi }, {si+1 }, , , . .", ". , )\nare equivalent to the state ({s1 }, {s2 }, . .", ". , {si 1 }, {fi }, {si+1 }, , , . .", ". , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , .", ". . , Si 1 , , , .", ". . , ) or of the\nform ({s1 }, {s2 }, .", ". . , {si 1 }, {fi }, Si+1 , Si+2 , .", ". . , Sk ).", "If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .", "Example 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .", "4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .", "8", "J. Jir sek, G. Jir skov \na2", "A1", "a2", "s1 =1", "a1", "2", "a2", "a2\na1", "...", "a1", "n1 1", "a1", "f1 =n1", "a1\na1", "A2", "s2 =1", "a1\na2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).", "Construct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2", "N", "a2", "s1 =1", "a1", "2", "a2\na1", "...", "a1", "n1 1", "a2\na1", "f1 =n1", "a1\na1\na1", "s2 =1", "a2\na1", "a2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).", "Let us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.", "State Complexity of Multiple Concatenation", "9", "Case 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1", "a", "1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2", "where the leftmost state is reachable as shown in Case 1.\naj 1", "Case 3: 2 j n1 1. Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b", "a2", "N", "s1 =1", "a1 , b", "2", "a2 , b\na1", "...", "a1", "n1 1", "a2 , b\na1", "f1 =n1", "a1\na2 , b", "a1\na1 , b", "a1", "s2 =1", "a2 , b", "a2", "2", "a1 , b", "a1 , b", "...", "a2", "n2 1", "a2", "f2 =n2", "a2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ).", "As shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na", "a", "a", "a", "a", "2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2}", "{2} \n{s2 }.", "Next, since n1 3, we have\nb", "a", "a", "a", "a", "1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1}", "{2} \n{s1 };", "10", "J. Jir sek, G. Jir skov \nb", "notice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb", "have {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.", "We use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}", "Ai", "si =1", "Σ \\ {ai }\nai , b", "2", "Σ \\ {ai }", "Σ \\ {ai }\nai", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "Figure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , . . . , ak }.", "First, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial. The next observation is crucial in what follows.", "It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }). Moreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.", "Lemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw", "S\n(i) (si 1 , {si }) \n(si 1 , S);", "u", "(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.", "State Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }", "Ni", "si 1", "ai 1 , b", "Σ \\ {ai 1 }", "ai 1", "2", "11", "ai 1", "...", "ni 1 1", "Σ \\ {ai 1 }", "ai 1", "fi 1", "ai 1\nΣ \\ {ai }", "ai 1", "Σ \\ {ai , b}", "si", "Σ \\ {ai }", "ai , b", "ai", "2", "Σ \\ {ai }", "Σ \\ {ai }", "...", "ai", "ni 1", "ai", "fi", "ai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).", "Proof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na", "a", "a", "a", "i\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2})", "(si 1 , {ni 1}) \n(si 1 , {fi }),", "so, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn", "i 1\nai 1", "am 1", "i\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),", "where the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .", "By induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).", "Now, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.", "12", "J. Jir sek, G. Jir skov \na2 , a3", "N", "s1", "a2 , a3 , b\na1 , b", "2", "a2 , a3 , b\na1", "a1\na1\na1 , a3", "s2", "f1\na2 , a3 , b\na1 , a3 , b", "a2 , b", "2", "a1 , a3 , b\na2", "3", "a2", "a1 , a3 , b\na2", "a2\na1 , a2", "s3", "f2\na1 , a3 , b\na1 , a2 , b", "a1 , a2 , b\na3 , b", "2", "a3", "f3", "a3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3.", "Theorem 12. Let k 2 and ni 3 for i = 1, 2 . .", ". , k. Let Ai be the ni -state DFA\nfrom Figure 4.", "Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ). Proof.", "We first prove reachability. Let q = (j, S2 , S3 , . .", ". , Sk ) be a valid state. If S2 = , then the state q = (j, , , .", ". . , ) is reached from the initial\nstate (s1 , , , .", ". . , ) by the string aj 1\n1 .", "Next, let = max{i 2 | Si = }. Then q = (j, S2 , S3 , . .", ". , S , , , . .", ". , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . .", ". , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , .", ". . , ) to\n(s1 , {s2 }, {s3 }, .", ". . , {s 1 }, {s }, , , .", ". . , ).", "Now, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . .", ", and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ). Moreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS .", "Since both a 1 and a perform identities on Q1 , Q2 , . . .", ", Q 2 , in\nthe subset automation D(N ) we have\nwS", "(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).", "State Complexity of Multiple Concatenation", "13", "Next, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1", "(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW", "(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na", "a", "b", "a", "a", "a", "b", "a", "a", "3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . .", ". , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, .", ". . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.", "Thus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. Notice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states.", "We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability.", "To this aim, let k 2, ni 2 for i = 1, 2, . . .", ", k,\nand Σ = {b, a1 , a2 , . . .", ", ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},", "14", "J. Jir sek, G. Jir skov", "that is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }", "Ai (i I)", "si =1", "Σ \\ {ai , ak }", "ai , ak", "2", "ai , ak", "Σ \\ {ai , ak }", "...", "ai , ak", "ni 2", "Σ \\ {ai , ak }", "ai , ak", "fi =ni", "ak", "ai\nΣ \\ {ai , b}", "Ai (i J)", "si =1", "Σ \\ {ai , b}\nai , b", "2", "Σ \\ {ai , b}", "Σ \\ {ai , b}\nai , b", "...", "ai , b", "ni 2", "ai , b", "fi =ni", "b", "ai\nΣ \\ {ak , b}", "Ak", "sk =1", "Σ \\ {ak , b}", "ak , b", "2", "ak , b", "Σ \\ {ak , b}", "...", "ak , b", "nk 2", "Σ \\ {ak , b}", "ak , b", "fk =nk", "ak", "b\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).", "each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.", "State Complexity of Multiple Concatenation", "15", "Construct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . .", ", Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . .", ", k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk . Theorem 13.", "Let k 2 and ni 2 for i = 1, 2, . . .", ", k. Let A1 , A2 , . .", ". , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).", "Proof. First, notice that Lemma 11 still holds for automata A1 , A2 , . .", ". , Ak 1 since\nthe transitions on a1 , a2 , . .", ". , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.", "Let ({j}, S2 , S3 , . . .", ", Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . .", ". , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12. Now, let Sk = .", "Then the state (s1 , {s2 }, {s3 }, . . .", ", {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ).", "However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components. Let u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak .", "Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . .", ", {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . .", ", {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . .", ", Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 . To prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb", "a", "a", "b", "a", "a", "a", "a", "b", "a", "a", "5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1", "{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.", "5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example.", "16", "J. Jir sek, G. Jir skov \na2 , a3 , a4 , b", "b", "A1", "s1", "a5", "2", "f1", "N", "a2 , a3 , a4 , b\na1 , a5", "s1", "a1 , a3 , a4 , a5", "s2", "a1 , a3 , a4 , a5 , b", "a2 , b\na1 , a2 , a4 , b", "s3", "2", "f3", "a1 , a2 , a4 , b\na3 , a5", "s3", "a1 , a2 , a3 , a5", "s4", "f4", "s4", "a4 , b", "s5", "f3", "a1 , a2 , a4 , a5 , b", "f4", "a1 , a2 , a3 , a4 , a5", "a1 , a2 , a3 , a4", "f5", "a3 , a5", "a1 , a2 , a3 , a5 , b", "a4 , b", "s5", "a1 , a2 , a4 , a5 , b", "a1 , a2 , a3 , a5 , b", "a4", "A5", "2\na3", "a3 , a5", "A4", "a2 , a3 , a4 , a5 , b", "f2", "a2", "A3", "f1", "a1 , a3 , a4 , a5 , b\na2 , b", "s2", "f2", "a1 , a5", "a1", "a1 , a5", "A2", "2", "a2 , a3 , a4 , a5 , b", "a5 , b", "f5", "b\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.", "State Complexity of Multiple Concatenation", "17", "Example 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb", "b", "b", "b\nb\nA", "s1 =1", "a", "a", "2", "3", "...", "a", "n1 1", "a", "f1 =n1", "a", "b", "B", "a", "s2 =1", "a", "a, b", "2", "3", "a, b", "...", "a, b", "n2 1", "a, b", "f2 =n2", "a, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.", "First, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na", "bm 2", "(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N .", "By Proposition 8,\nan upper bound is V2 = 2n2 1 . Finally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial.", "Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 .", "Let |S| 1. There are three cases to consider.", "18", "J. Jir sek, G. Jir skov", "Case 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na", "(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na", "bn2", "Case 2. b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.", "Case 2. c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.", "m 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2. a. Case 3: 2 j n1 1.", "Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2. This proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states.", "There are two cases to consider. Case 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N .", "Case 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 .", "The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 .", "Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise. First, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A. It follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.", "Now, let s2 an1 = s2 . Then we have\nan1 1", "a", "(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1", "b", "an1 1", "(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.", "State Complexity of Multiple Concatenation", "19", "Hence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states). Therefore, in what follows we assume that k 3. We use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , .", ". . , ak 1 }.", "The idea is as follows. The transitions on input symbols a1 , a2 , . .", ". , ak 1 in automata A1 , A2 , . .", ". , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, .", ". . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.", "To this aim, let k 3 and Σ = {b, a1 , a2 , . . .", ", ak 1 } be a k-letter alphabet. Let n1 , nk 2 and ni 3 for i = 2, 3, . .", ". , k 1. For i = 1, 2, .", ". . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, .", ". . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, .", ". . , ni ), b : ({2, 3, .", ". . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, .", ". . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.", "b\nb", "b", "b\nb", "Ai\n(i<k)", "si =1", "ai", "2", "ai", "3", "sk =1", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "b", "Ak", "ai", "ak 1", "2", "ak 1 , b", "3", "ak 1 , b", "...", "ak 1 , b", "nk 1", "ak 1 , b", "fk =nk", "ak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.", "20", "J. Jir sek, G. Jir skov", "Theorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . .", ". , k 1. Let A1 , A2 , .", ". . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , .", ". . , ak 1 }.", "Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all valid states are reachable and pairwise distinguishable in D(N ). Proof.", "Consider a valid state q = (j, S2 , . . .", ", Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , .", ". . , ak 1 in A1 , A2 , .", ". . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , .", ". . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.", "Now let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ).", "Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . .", ", sk 2 , we reach (s1 , {s2 }, {s3 }, . . .", ", {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS . Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi .", "Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, .", ". . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, .", ". . , {sk 2 }, Sk 1 , Sk ) by wSk 1 .", "The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 . To get distinguishability, let p = (S1 , S2 , S3 , . .", ". , Sk ) and q = (T1 , T2 , T3 , . .", ". , Tk )\nbe two distinct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .", "Let Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . .", ", k. Let us show that there is a string that sends p and q to two states which differ in si+1 . Without loss of generality, we have s Si \\ Ti .", "First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states", "(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )", "(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )", "where S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of", "the resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired", "result. Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", Ti+1\n, . . . , Tk )", "where q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.", "State Complexity of Multiple Concatenation", "21", "Case 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 . Thus after reading ai+1 b, we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", {si+1 }, Ti+2\n, . . . , Tk ).", "Finally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .", "Since the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.", "We conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3. Theorem 17.", "The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal. Proof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3.", "Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . .", ", ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . .", ", Ak 1 must\nhave one final state, and it must be different from the initial state. Construct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.", "Notice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 . If both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them. If both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw", "w", "from the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw", "w", "then it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.", "22", "J. Jir sek, G. Jir skov", "Hence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 . Next, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }.", "Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 .", "We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig.", "11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .", "Next, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 . Hence both a and b perform permutations on Q3 , thus resulting in a contradiction.", "b\nA2", "0", "p", "a", "q\nb", "f2", "Figure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .", "(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig.", "12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b.", "Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 . This means that s3 b = s3 . Hence b is a permutation on Q3 .", "Let r Q2 \\ {s2 b, f2 }. Then the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 .", "Thus both a and b perform a permutation\nin A2 , which is a contradiction.", "Notice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,", "State Complexity of Multiple Concatenation", "23\nb", "A2", "p", "0", "q", "a", "b", "f2", "Figure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .", "and the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc", "c", "a2", "b\nA1", "s1", "f1", "A2", "s2", "c", "s3", "b\na3", "a4\nf3", "A4", "c", "c", "s4", "s5", "b\na5", "c\na4", "f4", "b", "b", "a5\nA5", "f2", "b", "b", "a3\nA3", "c\na2", "b\nc", "b", "b", "a5\nf5", "A6", "s6", "c\na5", "f6", "Figure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has", "24", "J. Jir sek, G. Jir skov", "to be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .", "6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , .", ". . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k.", "Let us start\nwith the following example. Example 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end.", "Let us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state.", "Let |S| 2 and 1 S. Let m = min(S \\ {1}). Set S = abm 2 (S \\ {1, m}).", "Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2", "a", "{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.", "We now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end. Theorem 19.", "Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . .", ", k. Let A1 , A2 , . .", ". , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.", "Proof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . .", ". , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . .", ". , k 1 and σ {a, b}, by making states f1 , f2 , . .", ". , fk 1 non-final, and\nstates s2 , s3 , . .", ". , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them.", "Let N be the resulting NFA;\nsee Figure 16 for an illustration. In the subset automaton D(N ), each state (j, , , . .", ". , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . .", ". , ) by bj 1 , and (f1 , {s2 }, , , . .", ". , ) is\nreached from (f1 1, , , . .", ". , ) by b. Starting with the state f1 , the NFA N accepts\na, b", "N", "1", "a", "2", "a, b", "3", "a, b", "...", "a, b", "n 1", "a, b", "n", "Figure 14: A binary NFA N such that every set {1} S is reachable in D(N ).", "State Complexity of Multiple Concatenation", "25", "a, b", "a", "A1", "s1 =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "n1 2", "a, b", "n1 1", "b", "f1 =n1\na, b", "b", "A2", "a", "s2 =1", "a, b", "2", "3", "a, b", "...", "a, b", "n2 2", "a, b", "n2 1", "a, b", "f2 =n2\na, b", "Ai\n(i>2)", "si =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "ni 2", "a, b", "ni 1", "a, b", "fi =ni", "Figure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation.", "a, b\na\nN", "s1 =1", "a, b", "a, b", "b", "b", "s2 =1", "2", "a", "3", "b", "f1 =4\na, b", "a, b\n2", "a, b", "3", "a, b", "4", "a, b", "a, b", "2", "a, b", "3", "a, b", "f3 =4", "a, b", "a, b", "2", "a, b", "6", "5\na, b", "a, b\ns4 =1", "a, b", "a, b", "a, b\ns3 =1", "f2 =5", "3", "a, b", "f4 =4", "a, b", "5", "Figure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "26", "J. Jir sek, G. Jir skov", "all strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .", "Our next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case. Theorem 20.", "Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . .", ", k. There\nexist ternary DFAs A1 , A2 , . .", ". , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states. Proof.", "Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . .", ", n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , .", ". . , Sk ).", "Each such state is sent to the state (j, S2 , S3 , . . .", ", Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable.", "This gives the desired lower bound.", "7. Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5. 4 and 5.", "5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller.", "Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.", "Recall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . .", ", q 1 and a cycle p0 , p1 , . . .", ", pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6]. Let n1 , n2 , .", ". . , nk be positive integers with gcd(n1 , n2 , .", ". . , nk ) = 1.", "Then g(n1 , n2 , . . .", ", nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . .", ", xk . Let us star with the following observation.", "State Complexity of Multiple Concatenation", "27\na, b", "c\na\nN", "s1 =1", "a, b\nc", "c", "b", "c", "s2 =1", "a", "c", "a, b\nc", "2\nb", "a, b", "2\nc", "s3 =1", "a, b", "s4 =1", "a, b", "c\na, b", "2", "b\nc", "f1 =4", "c", "a, b", "c", "a, b", "3", "a, b", "a, b", "3", "a, b", "a, b", "4", "f2 =5", "a, b", "a, b\nc", "6", "a, b", "c", "f3 =4", "a, b\nc", "f4 =4", "a, b", "5", "c", "c\n3", "c", "a, b", "c", "2", "c", "3", "c\na, b", "5", "a, b", "Figure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "Lemma 21. Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.", "Let f (n1 , n2 , . . .", ", nk ) = g(n1 , n2 , . . .", ", nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result. Theorem 22.", "Let A1 , A2 , . . .", ", Ak be unary cyclic automata with n1 , n2 , . . .", ", nk\nstates, respectively. Let d = gcd(n1 , n2 , . .", ". , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , .", ". . , ndk ) k + 1,\nand this upper bound is tight.", "Proof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ).", "By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . .", ", ndk ) k + 1, we have am L if and only if am+d L. We can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8].", "Let m d f ( nd1 , nd2 , . . .", ", ndk ) k + 1. If am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi", "28", "J. Jir sek, G. Jir skov", "and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (", "n1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd", "n1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd", "d f(", "Since x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(", "nk\nn1 n2\n, , . . . , ) + 1,\nd d\nd", "and therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and only if\nd f (", "n1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd", "for some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(", "n1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1", "n2", "nk", "n1", "n2", "nk", "By Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.", "By [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.", "State Complexity of Multiple Concatenation", "29", "Corollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .", "In the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively. Example 24.", "Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j). As shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states.", "By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206. Nevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.", "Our next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages. In such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1. By [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.", "In both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this", "30", "J. Jir sek, G. Jir skov", "number by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <", "2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3", "Now, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.", "Motivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple.", "We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound. Theorem 25. For i = 1, 2, .", ". . , k, let Ai be a unary DFA of size (λi , i ).", "For a\nnon-empty set I = {i1 , i2 , . . .", ", i } {1, 2, . . .", ", k}, let\ndI = gcd(λi1 , λi2 , . . .", ", λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . .", ", ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . .", ". , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . .", ". , k}}. Proof.", "Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .", "I {1,2,. . .", ",k} j I\n/", "i I", "State Complexity of Multiple Concatenation", "31", "Q\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n(", "1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.", "The above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open. 8.", "Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . .", ". , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . .", ". , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , .", ". . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component.", "The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.", "Then we provided special binary witnesses for the concatenation of two languages. Using our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].", "For k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1]. We also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively.", "This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . .", ", nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.", "32", "J. Jir sek, G. Jir skov", "Finally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5. 4].", "We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails. Some problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, .", ". . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2.", "Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states. We proved the optimality of a ternary alphabet for the concatenation of three\nlanguages.", "However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal? Next, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2.", "What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ? Finally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails. The tightness of this upper bound remains open."]}
{"method": "semantic", "num_chunks": 515, "avg_chunk_len": 144.21941747572816, "std_chunk_len": 128.50138608164266, "max_chunk_len": 818, "min_chunk_len": 8, "total_chars": 74273, "compression_ratio": 1.0072839389818642, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025\n\narXiv:2511. 03814v1 [cs. FL] 5 Nov 2025\n\nSTATE COMPLEXITY OF MULTIPLE CONCATENATION\n\nJozef Jir sek\n(A)\n\n(A,B)\n\nGalina Jir skov \n\n(C,D)\n\nInstitute of Computer Science, P.", "J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef. jirasek@upjs.", "sk\n\n(C)\n\nMathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske. sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata.", "Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al. [2018, Fundam.", "Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal.", "We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails. Keywords: regular languages, multiple concatenation, state complexity\n\n1.", "Introduction\nGiven formal languages L1 , L2 , . . .", ", Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . .", ", k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton. A preliminary version of this paper appeared in Proc.", "DCFS 2020, LNCS vol. 12442, pp. 78 90.", "(B) Research supported by VEGA grant 1/0350/22. (D) Research supported by VEGA grant 2/0096/23. Jozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ.", "Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 .", "In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state. The concatenation of three and four regular languages was considered by sik et\nal.", "[2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4]. Caron et al.", "[1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages. In this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages.", "We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . .", ". , Ak are defined over the alphabet {b, a1 , . .", ". , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata.", "These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states.", "With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al.", "[1]. In the case of k = 3, we show that the ternary alphabet is optimal. We also examine multiple concatenation on binary, ternary, and unary languages.", "We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , . . .", ", nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.", "2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].", "The size of a finite set S is denoted by |S|, and the set of all its subsets by 2S . State Complexity of Multiple Concatenation\n\n3\n\nFor a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ .", "The multiple concatenation of k languages L1 , L2 , . . .", ", Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . .", ", uk Lk }. A deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ .", "The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }. All deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function. We usually omit , and write qa instead of q a.", "Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . .", ". , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , .", ". . , q ) the transformation that maps qi to qi+1 for i = 1, .", ". . , 1, the\nstate q to q1 , and fixes any other state in Q.", "In particular, (q1 ) denotes the identity. Next, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . .", ". , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.", "A state q Q is reachable in the DFA A if there is a string w Σ such that q = sw. Two states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .", "A DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , .", ". . , nk ) 7 max{sc(f (L1 , L2 , .", ". . , Lk )) | sc(Li ) ni for i = 1, 2, .", ". . , k}.", "A nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . .", ". , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . .", ". , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }.", "For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a. Let N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}.", "The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ). The reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ.", "Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions. A subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .", "We use the following two simple observations to prove distinguishability of states\nin subset automata. Lemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions.", "Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ). Proof.", "Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .", "Corollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. 3.", "Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.", "For i = 1, 2, . . .", ", k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . .", ". , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . .", ". , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . .", ". , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . .", ". , k 1; the initial state of N is s1 , and its set of final states is Fk . Since A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, .", ". . , k.", "We represent such a set by the k-tuple ({q}, S2 , S3 , . . .", ", Sk ), or\nmore often by (q, S2 , S3 , . . .", ", Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , .", ". . , Sk ) or (q, S2 a, S3 , .", ". . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .", "It follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . .", ", Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition. State Complexity of Multiple Concatenation\n\n5\n\nDefinition 3.", "A state (S1 , S2 , . . .", ", Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 . Since each reachable state of D(N ) is valid, we have the next observation. Proposition 4.", "An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ). Notice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi .", "If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , . . .", ", Ak as follows: for each i = 1, 2, . . .", ", k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk . For k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.", "Proposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .", "4\n\nProof. Every state (S1 , S2 , . .", ". , Sk ) with si Si for i = 2, 3, . .", ". , k is a valid state. This\ngives the left inequality.", "On the other hand, every state (S1 , S2 , . . .", ", Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality. We now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , .", ". . , Sk ) such that for fixed S1 , S2 , .", ". . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , .", ". . , Si 1 , Si , Si+1 , .", ". . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1 , .", ". . , Sk ) such that for a fixed S1 , S2 , .", ". . , Si 1\n\nwith fi 1 Si 1 the state (S1 , .", ". . , Si 1 , Si , Si+1 , .", ". . , Sk ) is valid.", "Then we have the next result. Theorem 6. Let k 2, ni 2 for i = 1, 2, .", ". . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi .", "Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ). Then\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G.", "Jir skov \n\nand for i = 2, 3, . . .", ", k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ). (2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 . (4)\n\nProof.", "If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).", "Let fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . .", ". , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).", "Let fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si .", "This gives (3). Finally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).", "Let us illustrate the above result in the following example. Example 7. Let k = 3 and n1 , n2 , n3 2.", "Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3. 6]. To conclude this section, let us consider also the case when some automata have just\none state.", "If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above.", "Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . .", ". , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }.", "If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state. State Complexity of Multiple Concatenation\n\n7\n\nProposition 8.", "Let k 2, j {1, 2, . . .", ", k}, nj = 1, and ni 2 if i = j. For i = 1, 2, . .", ". , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3).", "Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1. Proof. First, let j = 1.", "Then we have S1 = {f1 } in each valid state (S1 , S2 , . . .", ", Sk ). It follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 . Now, let j = k.", "Then all states (S1 , S2 , . . .", ", Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.", "Finally, let 2 j k 1. Then all states (S1 , S2 , . .", ". , Si 1 , {fi }, {si+1 }, , , . .", ". , )\nare equivalent to the state ({s1 }, {s2 }, . .", ". , {si 1 }, {fi }, {si+1 }, , , . .", ". , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , .", ". . , Si 1 , , , .", ". . , ) or of the\nform ({s1 }, {s2 }, .", ". . , {si 1 }, {fi }, Si+1 , Si+2 , .", ". . , Sk ).", "If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 . Example 9.", "Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 .", "This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ . 4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp.", "266 271]. We use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.", "Example 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1.", "The symbol a1 performs the circular shift in A1 , and the identity in A2 . Symmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 . 8\n\nJ.", "Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n. .", ". a1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n. .", ". a2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ). Construct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial.", "The NFA N is shown in Figure 2. a2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n. .", ". a1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n. .", ". a2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ). Let us show that each valid state (j, S) is reachable in the subset automaton D(N ).", "The proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.", "There are three cases to consider. Case 1: j = f1 . Then s2 S since (f1 , S) is valid.", "Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction. State Complexity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S.", "Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1. aj 1\n\nCase 3: 2 j n1 1.", "Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2. Thus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 .", "It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state. To guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.", "a2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n. . .", "a1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n. . .", "a2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ). As shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N .", "In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }. Next, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G.", "Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.", "We use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . .", ". , k. Let Σ = {b, a1 , a2 , .", ". . , ak } be an alphabet consisting of k + 1\nsymbols.", "Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . .", ", ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . .", ", ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}. Σ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n.", ". . ai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , .", ". . , ak }.", "First, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial. The next observation is crucial in what follows.", "It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }). Moreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.", "Lemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.", "State Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1 , b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n. . .", "ni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n. . .", "ai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i). Proof. The proof of both (i) and (ii) is by induction on |S|.", "The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n. i\nLet |S| 2.", "Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n.", "Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S . By induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).", "Now, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . .", ", Ak as follows: First, for each i = 1, 2, . . .", ", k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . .", ". , fk 1 non-final, and states s2 , s3 , . .", ". , sk non-initial; see Figure 6 for\nan illustration. 12\n\nJ.", "Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3. Theorem 12.", "Let k 2 and ni 3 for i = 1, 2 . . .", ", k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.", "Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ). Proof. We first prove reachability.", "Let q = (j, S2 , S3 , . . .", ", Sk ) be a valid state. If S2 = , then the state q = (j, , , . .", ". , ) is reached from the initial\nstate (s1 , , , . .", ". , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.", "Then q = (j, S2 , S3 , . . .", ", S , , , . . .", ", ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . .", ", . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . .", ". , ) to\n(s1 , {s2 }, {s3 }, . .", ". , {s 1 }, {s }, , , . .", ". , ). Now, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , .", ". . , and ending with S3 and S2 .", "By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ). Moreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , .", ". . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, .", ". . , {s 1 }, {s }, , .", ". . , ) \n(s1 , {s2 }, .", ". . , {s 1 }, S , , .", ". . , ).", "State Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . .", ". , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . .", ". , {s 2 }, {s 1 }, S , , . .", ". , ) (s1 , {s2 }, . .", ". , {s 2 }, S 1 , S , , . .", ". , ). Now, for i = 2, 3, .", ". . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ).", "Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , .", ". . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , .", ". . , A .", "Set W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . .", ". , {s 2 }, S 1 , S , , . .", ". , ) (s1 , S2 , . .", ". , S 2 , S 1 , S , , . .", ". , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , .", ". . , S , , , .", ". . , ) is reached from the initial state (s1 , , , .", ". . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .", "To get distinguishability, let us show that each singleton set is co-reachable in N . First, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na\n\na\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . .", ". , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, .", ". . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.", "Thus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. Notice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states.", "We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability.", "To this aim, let k 2, ni 2 for i = 1, 2, . . .", ", k,\nand Σ = {b, a1 , a2 , . . .", ", ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G.", "Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others. Consider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . .", ". , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . .", ". , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . .", ". , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . .", ". , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n. .", ". ai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\ {ai , b}\nai , b\n\n. .", ". ai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n. .", ". ak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom). each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.", "State Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . .", ", Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . .", ", k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk . Theorem 13.", "Let k 2 and ni 2 for i = 1, 2, . . .", ", k. Let A1 , A2 , . .", ". , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).", "Proof. First, notice that Lemma 11 still holds for automata A1 , A2 , . .", ". , Ak 1 since\nthe transitions on a1 , a2 , . .", ". , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.", "Let ({j}, S2 , S3 , . . .", ", Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . .", ". , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12. Now, let Sk = .", "Then the state (s1 , {s2 }, {s3 }, . . .", ", {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ).", "However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components. Let u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak .", "Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . .", ", {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . .", ", {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . .", ", Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 . To prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b. Finally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i .", "It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable. 5.", "Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example. 16\n\nJ.", "Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1 , a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2. State Complexity of Multiple Concatenation\n\n17\n\nExample 14.", "Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9. Let us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages. b\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n.", ". . a\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n.", ". . a, b\n\nn2 1\n\na, b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.", "First, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.", "Now, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final.", "Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|.", "The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.", "Then abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N .", "By Proposition 8,\nan upper bound is V2 = 2n2 1 . Finally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial.", "Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 .", "Let |S| 1. There are three cases to consider. 18\n\nJ.", "Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid.", "We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction. Case 2: j = s1 . Case 2.", "a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1. a\n\nbn2\n\nCase 2.", "b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1. Case 2.", "c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }. m 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.", "a. Case 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.", "This proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.", "Case 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N . Case 2: S = T and i < j.", "First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1.", "Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.", "First, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A. It follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings. Now, let s2 an1 = s2 .", "Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component. Finally, let s2 an1 = s2 .", "Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component. This proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.", "State Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states). Therefore, in what follows we assume that k 3. We use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , .", ". . , ak 1 }.", "The idea is as follows. The transitions on input symbols a1 , a2 , . .", ". , ak 1 in automata A1 , A2 , . .", ". , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, .", ". . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.", "To this aim, let k 3 and Σ = {b, a1 , a2 , . . .", ", ak 1 } be a k-letter alphabet. Let n1 , nk 2 and ni 3 for i = 2, 3, . .", ". , k 1. For i = 1, 2, .", ". . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, .", ". . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, .", ". . , ni ), b : ({2, 3, .", ". . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, .", ". . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.", "b\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n. . .", "ai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb\n\nAk\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n. . .", "ak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . .", ", k 1. Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . .", ". , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . .", ". , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ).", "The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time. 20\n\nJ.", "Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, .", ". . , k 1.", "Let A1 , A2 , . . .", ", Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . .", ", ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all valid states are reachable and pairwise distinguishable in D(N ).", "Proof. Consider a valid state q = (j, S2 , . .", ". , Sk 1 , Sk ). First, let Sk = .", "Since the\ntransitions on a1 , a2 , . . .", ", ak 1 in A1 , A2 , . . .", ", Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . .", ", Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem. Now let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14.", "As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . .", ". , sk 2 , we reach (s1 , {s2 }, {s3 }, . .", ". , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS . Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ).", "Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 .", "Then the\nstate (s1 , {s2 }, {s3 }, . . .", ", {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . .", ", {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 . To get distinguishability, let p = (S1 , S2 , S3 , .", ". . , Sk ) and q = (T1 , T2 , T3 , .", ". . , Tk )\nbe two distinct valid states.", "If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 . Let Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . .", ". , k. Let us show that there is a string that sends p and q to two states which differ in si+1 .", "Without loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . .", ". , Si 1\n, S (Si w), Si+1\n, . .", ". , Sk )\n\n(T1 , T2 , T3 , . .", ". , Ti 1\n, T (Ti w), Ti+1\n, . .", ". , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult.", "Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . .", ", Si and all T1 , T2 , . . .", ", Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 }, {s3 }, .", ". . , {si 1 }, S {fi }, Si+1\n, .", ". . , Sk )\n\n({s1 }, {s2 }, {s3 }, .", ". . , {si 1 },\n\n{si }\n\n, Ti+1\n, .", ". . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, .", ". . , k 1.", "There are two cases to consider. State Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 .", "Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . .", ", {si 1 }, S {fi }, {si+1 }, Si+2\n, . . .", ", Sk )\n\n({s1 }, {s2 }, {s3 }, . . .", ", {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . .", ", Tk ). Finally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 . Case 2: i = k 1.", "Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . .", ", k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . .", ". , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . .", ". , {sk 2 }, {sk 1 }, {sk }). k\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .", "Since the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result. Corollary 16. The DFAs A1 , A2 , .", ". . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.", "We conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3. Theorem 17.", "The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal. Proof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3.", "Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . .", ", ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . .", ", Ak 1 must\nhave one final state, and it must be different from the initial state. Construct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.", "Notice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 . If both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them. If both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.", "22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .", "Next, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a.", "Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 .", "Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11.", "Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 . Next, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 .", "It follows that b is a permutation on Q3 . Hence both a and b perform permutations on Q3 , thus resulting in a contradiction. b\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .", "(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig.", "12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b.", "Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 . This means that s3 b = s3 . Hence b is a permutation on Q3 .", "Let r Q2 \\ {s2 b, f2 }. Then the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 .", "Thus both a and b perform a permutation\nin A2 , which is a contradiction. Notice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states.", "Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case. Let Σ = {b, c, a2 , a3 , .", ". . ak 1 } be a k-letter alphabet.", "For i = 1, 2, . . .", ", k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 . and the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . .", ". , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . .", ". , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise. c\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6.", "In each DFA, the remaining symbols perform identities. Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . .", ". , Ak as\nfollows: for each i = 1, 2, . .", ". , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk . We prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , .", ". . , Tk ) from a state q = (s1 , S2 , S3 , .", ". . , Sk ), the symbol b has\n\n24\n\nJ.", "Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }.", "Then, we have to carefully return {si } back to Si . 6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages.", "Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . .", ", nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example. Example 18.", "Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end. Let us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|.", "The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).", "Set S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.", "We now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end. Theorem 19.", "Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . .", ", k. Let A1 , A2 , . .", ". , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.", "Proof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . .", ". , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . .", ". , k 1 and σ {a, b}, by making states f1 , f2 , . .", ". , fk 1 non-final, and\nstates s2 , s3 , . .", ". , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them.", "Let N be the resulting NFA;\nsee Figure 16 for an illustration. In the subset automaton D(N ), each state (j, , , . .", ". , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . .", ". , ) by bj 1 , and (f1 , {s2 }, , , . .", ". , ) is\nreached from (f1 1, , , . .", ". , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n.", ". . a, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).", "State Complexity of Multiple Concatenation\n\n25\n\na, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n. . .", "a, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n. . .", "a, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n. . .", "a, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . .", ", k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation. a, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5. 26\n\nJ.", "Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , .", ". . , Sk ) with S2 {2, 3, .", ". . , n2 2},\nSi {1, 2, .", ". . , ni 2} for i = 3, 4, .", ". . , k 1, and Sk {1, 2, .", ". . , nk 1} is reachable.", "This gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states. Moreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , .", ". . , Sk )\nand (j, T2 , T3 , .", ". . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 .", "Next, the states (i, S2 , S3 , . . .", ", Sk ) and (j, S2 , S3 , . . .", ", Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j . Our next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.", "Theorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . .", ". , k. There\nexist ternary DFAs A1 , A2 , .", ". . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states.", "Proof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . .", ". , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration.", "As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . .", ", Sk ). Each such state is sent to the state (j, S2 , S3 , . .", ". , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c .", "By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound. 7.", "Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5. 4 and 5. 5].", "This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic.", "In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails. Recall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , .", ". . , q 1 and a cycle p0 , p1 , .", ". . , pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf.", "[6]. Let n1 , n2 , . .", ". , nk be positive integers with gcd(n1 , n2 , . .", ". , nk ) = 1. Then g(n1 , n2 , .", ". . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , .", ". . , xk .", "Let us star with the following observation. State Complexity of Multiple Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5. Lemma 21.", "Let n1 , n2 , . . .", ", nk be positive integers with gcd(n1 , n2 , . . .", ", nk ) = d. Then each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . .", ". , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , .", ". . , xk 0, is d g( nd1 , nd2 , .", ". . , ndk ).", "Proof. The first claim follows from the fact that each ni is a multiple of d. Since gcd( nd1 , nd2 , .", ". . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , .", ". . , xk 0, is g( nd1 , nd2 , .", ". . , ndk ).", "Multiplying by d, we get the second claim. Let f (n1 , n2 , . .", ". , nk ) = g(n1 , n2 , . .", ". , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result.", "Theorem 22. Let A1 , A2 , . .", ". , Ak be unary cyclic automata with n1 , n2 , . .", ". , nk\nstates, respectively. Let d = gcd(n1 , n2 , .", ". . , nk ).", "Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . .", ", ndk ) k + 1,\nand this upper bound is tight. Proof. Denote Li = L(Ai ) and L = L1 L2 Lk .", "We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . .", ". , ndk ) k + 1, we have am L if and only if am+d L. We can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf.", "[6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . .", ". , ndk ) k + 1. If am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ.", "Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , .", ". . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , .", ". . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , .", ". . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , .", ". . , ) + 1.", "d d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . .", ", x k 0. Therefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L. Conversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0.", "Since m d f ( nd1 , nd2 , . . .", ", ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(\n\nnk\nn1 n2\n, , . . .", ", ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . .", ", x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L. To get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata.", "Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . .", ". , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , .", ". . , xk 0.", "Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,. .", ". , d ) k+ d is in L if and only if\nd f (\n\nn1 n2\nnk\n, , . .", ". , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . .", ". , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . .", ". , ) + d = x1 n1 + x2 n2 + + xk nk . d d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,.", ". . , d ) k \n/ L, while ad f ( d , d ,.", ". . , d ) k+d L.", "Hence A is minimal. By [3, Proposition 2. 2], if n1 n2 nk , then g(n1 , n2 , .", ". . , nk ) n1 nk .", "This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . .", ", nk ). The result of the\nprevious theorem can be generalized as follows. State Complexity of Multiple Concatenation\n\n29\n\nCorollary 23.", "For i = 1, 2, . . .", ", Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . .", ". , λk ). Then the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , .", ". . , λdk ) k + 1, and this upper bound is\ntight.", "Proof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf.", "[6, Theorem 6]. The upper bound is met by languages Li = a i +λi 1 (aλi ) . In the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11].", "The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively. Example 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1.", "If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j). As shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.", "Nevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other. Our next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.", "In such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1. By [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1. In both cases, the resulting complexity is at most (m i)(n j) + i + j.", "Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j.", "The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3. If follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}. Assume that in all of this cases, we have gcd(m i, n j) 3.", "Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1. 3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.", "Moreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails. Motivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails.", "While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.", "Theorem 25. For i = 1, 2, . .", ". , k, let Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , .", ". . , i } {1, 2, .", ". . , k}, let\ndI = gcd(λi1 , λi2 , .", ". . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , .", ". . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0.", "Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . .", ", λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . .", ", k}}. Proof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ).", "We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi . I {1,2,.", ". . ,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).", "The concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4].", "Example 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}. We have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.", "The size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}. The above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.", "8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , .", ". . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , .", ". . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction.", "Using symbols a1 , a2 , . . .", ", ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states.", "Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states. Then we provided special binary witnesses for the concatenation of two languages. Using our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet.", "This solves an open problem stated in [1]. For k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].", "We also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . .", ". , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages. 32\n\nJ.", "Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.", "4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails. Some problems remain open.", "First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . .", ", k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.", "We proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?", "Next, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ? Finally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.", "The tightness of this upper bound remains open."]}
{"method": "delimiter", "num_chunks": 767, "avg_chunk_len": 95.50586701434159, "std_chunk_len": 326.1076555824217, "max_chunk_len": 3326, "min_chunk_len": 1, "total_chars": 73253, "compression_ratio": 1.0213097074522546, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025", "arXiv:2511.03814v1 [cs.FL] 5 Nov 2025", "STATE COMPLEXITY OF MULTIPLE CONCATENATION", "Jozef Jir sek\n(A)", "(A,B)", "Galina Jir skov", "(C,D)", "Institute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk", "(C)", "Mathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk", "ABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.", "Keywords: regular languages, multiple concatenation, state complexity", "1. Introduction\nGiven formal languages L1 , L2 , . . . , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.", "Jozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197", "2", "J. Jir sek, G. Jir skov", "The first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .", "State Complexity of Multiple Concatenation", "3", "For a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by", "4", "J. Jir sek, G. Jir skov", "swapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .", "Corollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 , . . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition.", "State Complexity of Multiple Concatenation", "5", "Definition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).", "Notice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1", "n1 2n2 +n3 + +nk #τk", "3\nn1 2n2 +n3 + +nk .\n4", "Proof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality.", "We now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let", "Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1", "with fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,", "Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1", "with fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.", "Theorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,", "(1)", "6", "J. Jir sek, G. Jir skov", "and for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2", "Vi = 2", "(Ui+1 + Vi+1 ).", "(2)\n(3)", "Finally, we have\n#τk = (n1 1)U2 + V2 .", "(4)", "Proof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).", "Let fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).", "Let fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).", "Let us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].", "To conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.", "State Complexity of Multiple Concatenation", "7", "Proposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then", "V2 ,\nif j = 1;", "n1 ,\nif j = k = 2;", "(n 1)U + V + 1\n1\n2\n2\nsc(L)", "with\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1", "(n1 1)U2 + V2 + Vi+1", "with Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .", "Example 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .", "4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .", "8", "J. Jir sek, G. Jir skov \na2", "A1", "a2", "s1 =1", "a1", "2", "a2", "a2\na1", "...", "a1", "n1 1", "a1", "f1 =n1", "a1\na1", "A2", "s2 =1", "a1\na2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).", "Construct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2", "N", "a2", "s1 =1", "a1", "2", "a2\na1", "...", "a1", "n1 1", "a2\na1", "f1 =n1", "a1\na1\na1", "s2 =1", "a2\na1", "a2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).", "Let us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.", "State Complexity of Multiple Concatenation", "9", "Case 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1", "a", "1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2", "where the leftmost state is reachable as shown in Case 1.\naj 1", "Case 3: 2 j n1 1. Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b", "a2", "N", "s1 =1", "a1 , b", "2", "a2 , b\na1", "...", "a1", "n1 1", "a2 , b\na1", "f1 =n1", "a1\na2 , b", "a1\na1 , b", "a1", "s2 =1", "a2 , b", "a2", "2", "a1 , b", "a1 , b", "...", "a2", "n2 1", "a2", "f2 =n2", "a2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ).", "As shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na", "a", "a", "a", "a", "2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2}", "{2} \n{s2 }.", "Next, since n1 3, we have\nb", "a", "a", "a", "a", "1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1}", "{2} \n{s1 };", "10", "J. Jir sek, G. Jir skov \nb", "notice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb", "have {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.", "We use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}", "Ai", "si =1", "Σ \\ {ai }\nai , b", "2", "Σ \\ {ai }", "Σ \\ {ai }\nai", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "Figure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , . . . , ak }.", "First, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in what follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw", "S\n(i) (si 1 , {si }) \n(si 1 , S);", "u", "(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.", "State Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }", "Ni", "si 1", "ai 1 , b", "Σ \\ {ai 1 }", "ai 1", "2", "11", "ai 1", "...", "ni 1 1", "Σ \\ {ai 1 }", "ai 1", "fi 1", "ai 1\nΣ \\ {ai }", "ai 1", "Σ \\ {ai , b}", "si", "Σ \\ {ai }", "ai , b", "ai", "2", "Σ \\ {ai }", "Σ \\ {ai }", "...", "ai", "ni 1", "ai", "fi", "ai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).", "Proof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na", "a", "a", "a", "i\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2})", "(si 1 , {ni 1}) \n(si 1 , {fi }),", "so, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn", "i 1\nai 1", "am 1", "i\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),", "where the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .", "By induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).", "Now, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.", "12", "J. Jir sek, G. Jir skov \na2 , a3", "N", "s1", "a2 , a3 , b\na1 , b", "2", "a2 , a3 , b\na1", "a1\na1\na1 , a3", "s2", "f1\na2 , a3 , b\na1 , a3 , b", "a2 , b", "2", "a1 , a3 , b\na2", "3", "a2", "a1 , a3 , b\na2", "a2\na1 , a2", "s3", "f2\na1 , a3 , b\na1 , a2 , b", "a1 , a2 , b\na3 , b", "2", "a3", "f3", "a3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3.", "Theorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j, , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3 }, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS", "(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).", "State Complexity of Multiple Concatenation", "13", "Next, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1", "(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW", "(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na", "a", "b", "a", "a", "a", "b", "a", "a", "3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},", "14", "J. Jir sek, G. Jir skov", "that is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }", "Ai (i I)", "si =1", "Σ \\ {ai , ak }", "ai , ak", "2", "ai , ak", "Σ \\ {ai , ak }", "...", "ai , ak", "ni 2", "Σ \\ {ai , ak }", "ai , ak", "fi =ni", "ak", "ai\nΣ \\ {ai , b}", "Ai (i J)", "si =1", "Σ \\ {ai , b}\nai , b", "2", "Σ \\ {ai , b}", "Σ \\ {ai , b}\nai , b", "...", "ai , b", "ni 2", "ai , b", "fi =ni", "b", "ai\nΣ \\ {ak , b}", "Ak", "sk =1", "Σ \\ {ak , b}", "ak , b", "2", "ak , b", "Σ \\ {ak , b}", "...", "ak , b", "nk 2", "Σ \\ {ak , b}", "ak , b", "fk =nk", "ak", "b\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).", "each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.", "State Complexity of Multiple Concatenation", "15", "Construct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb", "a", "a", "b", "a", "a", "a", "a", "b", "a", "a", "5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1", "{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.", "5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example.", "16", "J. Jir sek, G. Jir skov \na2 , a3 , a4 , b", "b", "A1", "s1", "a5", "2", "f1", "N", "a2 , a3 , a4 , b\na1 , a5", "s1", "a1 , a3 , a4 , a5", "s2", "a1 , a3 , a4 , a5 , b", "a2 , b\na1 , a2 , a4 , b", "s3", "2", "f3", "a1 , a2 , a4 , b\na3 , a5", "s3", "a1 , a2 , a3 , a5", "s4", "f4", "s4", "a4 , b", "s5", "f3", "a1 , a2 , a4 , a5 , b", "f4", "a1 , a2 , a3 , a4 , a5", "a1 , a2 , a3 , a4", "f5", "a3 , a5", "a1 , a2 , a3 , a5 , b", "a4 , b", "s5", "a1 , a2 , a4 , a5 , b", "a1 , a2 , a3 , a5 , b", "a4", "A5", "2\na3", "a3 , a5", "A4", "a2 , a3 , a4 , a5 , b", "f2", "a2", "A3", "f1", "a1 , a3 , a4 , a5 , b\na2 , b", "s2", "f2", "a1 , a5", "a1", "a1 , a5", "A2", "2", "a2 , a3 , a4 , a5 , b", "a5 , b", "f5", "b\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.", "State Complexity of Multiple Concatenation", "17", "Example 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb", "b", "b", "b\nb\nA", "s1 =1", "a", "a", "2", "3", "...", "a", "n1 1", "a", "f1 =n1", "a", "b", "B", "a", "s2 =1", "a", "a, b", "2", "3", "a, b", "...", "a, b", "n2 1", "a, b", "f2 =n2", "a, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.", "First, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na", "bm 2", "(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\nan upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.", "18", "J. Jir sek, G. Jir skov", "Case 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na", "(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na", "bn2", "Case 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1", "a", "(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1", "b", "an1 1", "(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.", "State Complexity of Multiple Concatenation", "19", "Hence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb", "b", "b\nb", "Ai\n(i<k)", "si =1", "ai", "2", "ai", "3", "sk =1", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "b", "Ak", "ai", "ak 1", "2", "ak 1 , b", "3", "ak 1 , b", "...", "ak 1 , b", "nk 1", "ak 1 , b", "fk =nk", "ak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.", "20", "J. Jir sek, G. Jir skov", "Theorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N ).\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .\nNext, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two distinct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states", "(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )", "(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )", "where S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of", "the resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired", "result. Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", Ti+1\n, . . . , Tk )", "where q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.", "State Complexity of Multiple Concatenation", "21", "Case 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 . Thus after reading ai+1 b, we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", {si+1 }, Ti+2\n, . . . , Tk ).", "Finally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .", "Since the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.", "We conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw", "w", "from the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw", "w", "then it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.", "22", "J. Jir sek, G. Jir skov", "Hence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2", "0", "p", "a", "q\nb", "f2", "Figure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .", "(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.", "Notice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,", "State Complexity of Multiple Concatenation", "23\nb", "A2", "p", "0", "q", "a", "b", "f2", "Figure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .", "and the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc", "c", "a2", "b\nA1", "s1", "f1", "A2", "s2", "c", "s3", "b\na3", "a4\nf3", "A4", "c", "c", "s4", "s5", "b\na5", "c\na4", "f4", "b", "b", "a5\nA5", "f2", "b", "b", "a3\nA3", "c\na2", "b\nc", "b", "b", "a5\nf5", "A6", "s6", "c\na5", "f6", "Figure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has", "24", "J. Jir sek, G. Jir skov", "to be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2", "a", "{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.", "We now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each state (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b", "N", "1", "a", "2", "a, b", "3", "a, b", "...", "a, b", "n 1", "a, b", "n", "Figure 14: A binary NFA N such that every set {1} S is reachable in D(N ).", "State Complexity of Multiple Concatenation", "25", "a, b", "a", "A1", "s1 =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "n1 2", "a, b", "n1 1", "b", "f1 =n1\na, b", "b", "A2", "a", "s2 =1", "a, b", "2", "3", "a, b", "...", "a, b", "n2 2", "a, b", "n2 1", "a, b", "f2 =n2\na, b", "Ai\n(i>2)", "si =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "ni 2", "a, b", "ni 1", "a, b", "fi =ni", "Figure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation.", "a, b\na\nN", "s1 =1", "a, b", "a, b", "b", "b", "s2 =1", "2", "a", "3", "b", "f1 =4\na, b", "a, b\n2", "a, b", "3", "a, b", "4", "a, b", "a, b", "2", "a, b", "3", "a, b", "f3 =4", "a, b", "a, b", "2", "a, b", "6", "5\na, b", "a, b\ns4 =1", "a, b", "a, b", "a, b\ns3 =1", "f2 =5", "3", "a, b", "f4 =4", "a, b", "5", "Figure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "26", "J. Jir sek, G. Jir skov", "all strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .", "Our next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.", "7. Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.", "State Complexity of Multiple Concatenation", "27\na, b", "c\na\nN", "s1 =1", "a, b\nc", "c", "b", "c", "s2 =1", "a", "c", "a, b\nc", "2\nb", "a, b", "2\nc", "s3 =1", "a, b", "s4 =1", "a, b", "c\na, b", "2", "b\nc", "f1 =4", "c", "a, b", "c", "a, b", "3", "a, b", "a, b", "3", "a, b", "a, b", "4", "f2 =5", "a, b", "a, b\nc", "6", "a, b", "c", "f3 =4", "a, b\nc", "f4 =4", "a, b", "5", "c", "c\n3", "c", "a, b", "c", "2", "c", "3", "c\na, b", "5", "a, b", "Figure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "Lemma 21. Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.", "Let f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is tight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi", "28", "J. Jir sek, G. Jir skov", "and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (", "n1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd", "n1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd", "d f(", "Since x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(", "nk\nn1 n2\n, , . . . , ) + 1,\nd d\nd", "and therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and only if\nd f (", "n1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd", "for some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(", "n1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1", "n2", "nk", "n1", "n2", "nk", "By Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.", "By [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.", "State Complexity of Multiple Concatenation", "29", "Corollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .", "In the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this", "30", "J. Jir sek, G. Jir skov", "number by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <", "2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3", "Now, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.", "Motivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/", "i I", "State Complexity of Multiple Concatenation", "31", "Q\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n(", "1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.", "The above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.", "32", "J. Jir sek, G. Jir skov", "Finally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound remains open."]}
{"method": "token_limit", "num_chunks": 94, "avg_chunk_len": 795.3829787234042, "std_chunk_len": 39.75994626879442, "max_chunk_len": 800, "min_chunk_len": 412, "total_chars": 74766, "compression_ratio": 1.0006420030495145, "avg_chunk_tokens": 198.5531914893617, "max_chunk_tokens": 200, "min_chunk_tokens": 103, "tokenizer": "", "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025\n\narXiv:2511.03814v1 [cs.FL] 5 Nov 2025\n\nSTATE COMPLEXITY OF MULTIPLE CONCATENATION\n\nJozef Jir sek\n(A)\n\n(A,B)\n\nGalina Jir skov \n\n(C,D)\n\nInstitute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk\n\n(C)\n\nMathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automa", "ta. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.\n\nKeywords: regular languages, multiple concatenation, state complexity\n\n1. Introduction\nGiven formal languages L1 , L2 , . .", ". , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.\n\nJozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ. Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov", "[5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s univer", "sal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concat", "enation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain", "exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .\n\nState Complexity of Multiple Concatenation\n\n3\n\nFor a fi", "nite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be comple", "te; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states", "p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w i", "n Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R =", "(Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ. Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final state", "s F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .\n\nCorollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assum", "e that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 ,", ". . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the n", "ext definition.\n\nState Complexity of Multiple Concatenation\n\n5\n\nDefinition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).\n\nNotice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs", "A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .\n4\n\nProof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand", "s3 \n/ S3 is not valid, which gives the right inequality.\n\nWe now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.\n\nTheorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accept", "ing L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G. Jir skov \n\nand for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ).\n\n(2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 .\n\n(4)\n\nProof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).\n\nLet fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).\n\nLet fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,", "namely, S1 = {f1 }, to be final. This gives (4).\n\nLet us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].\n\nTo conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one i", "nitial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.\n\nState Complexity of Multiple Concatenation\n\n7\n\nProposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)", "U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input sy", "mbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .\n\nExample 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an u", "pper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .\n\n4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .\n\n8\n\nJ", ". Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).\n\nConstruct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).\n\nLet us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0,", "holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.\n\nState Complexity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1.\naj 1\n\nCase 3: 2 j n1 1. Then we have (s1 , S)", "1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n...\n\na1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N", "recognizing the language L(A 1 )L(A 2 ).\n\nAs shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }.\n\nNext, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G. Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.\n\nWe use the ideas from the above example to describe witnesses for multiple concatenatio", "n over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-", "letter alphabet {b, a1 , a2 , . . . , ak }.\n\nFirst, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in what follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA", "for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.\n\nState Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1 , b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n...\n\nni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n...\n\nai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).\n\nProof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si", "}) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .\n\nBy induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, re", "spectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).\n\nNow, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.\n\n12\n\nJ. Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with", "n1 = 3, n2 = 4, and n3 = 3.\n\nTheorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j, , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3", "}, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).\n\nState Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } wh", "ich\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to", "itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na", "a\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automat", "a have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G. Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },", "if i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n...\n\nai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\ {ai , b}\nai , b\n\n...\n\nai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n...\n\nak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).\n\n each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni )", "on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.\n\nState Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1", ")L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the l", "emma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an exam", "ple, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.\n\n5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for mult", "iple concatenation over a kletter alphabet. Let us start with the following example.\n\n16\n\nJ. Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1 , a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(", "A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.\n\nState Complexity of Multiple Concatenation\n\n17\n\nExample 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n...\n\na\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.\n\nFirst, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfro", "m the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\na", "n upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.\n\n18\n\nJ. Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from", "(f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na\n\nbn2\n\nCase 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons", "{q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in", "this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.\n\nState Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in", "what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ,", ", si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb\n\nAk\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n...\n\nak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding t", "he transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.\n\n20\n\nJ. Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N", ").\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .", "Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two disti", "nct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )\n\n(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult. Othe", "rwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, Ti+1\n, . . . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.\n\nState Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 t", "o si+1 . Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . . , Tk ).\n\nFinally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states w", "hich differ in sk .\n\nSince the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.\n\nWe conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bo", "und for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a per", "mutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.\n\n22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\", "{f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the th", "ird component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .\n\n(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the", "state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.\n\nNotice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to co", "ver such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .\n\nand the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the", "contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p =", "(f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has\n\n24\n\nJ. Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings", "over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.\n\nWe now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a", "in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each sta", "te (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n...\n\na, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).\n\nState Complexity of Multiple Concatenation\n\n25\n\na, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenat", "ion.\n\na, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\n26\n\nJ. Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}", "where q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .\n\nOur next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2", "n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.\n\n7. Unary Languages\nThe upper bo", "und on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntra", "nsitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.\n\nState Complexity of Multiple Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\nLemma 21", ". Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.\n\nLet f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is n", "ot representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is tight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf a", "m L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ. Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d", "d g(\n\nnk\nn1 n2\n, , . . . , ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and", "only if\nd f (\n\nn1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.\n\nBy [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.\n\nState Complexity of Multiple Concatenation\n\n29\n\nCorollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language", "recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .\n\nIn the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the lea", "st common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes", "(m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1,", "n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all", "i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is ac", "hieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.\n\nMotivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let", "Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/", "i I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.\n\nThe above example shows that our upper bound given by Theorem 25 is met", "by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and theref", "ore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concate", "nation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.\n\n32\n\nJ. Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met", "by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where", "exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound remains open."]}
{"method": "format_aware", "num_chunks": 1, "avg_chunk_len": 74813.0, "std_chunk_len": 0.0, "max_chunk_len": 74813, "min_chunk_len": 74813, "total_chars": 74813, "compression_ratio": 1.0000133666608744, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025\n\narXiv:2511.03814v1 [cs.FL] 5 Nov 2025\n\nSTATE COMPLEXITY OF MULTIPLE CONCATENATION\n\nJozef Jir sek\n(A)\n\n(A,B)\n\nGalina Jir skov \n\n(C,D)\n\nInstitute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk\n\n(C)\n\nMathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk\n\nABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet. This solves an open problem stated by Caron et al.\n[2018, Fundam. Inform. 160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case. Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.\n\nKeywords: regular languages, multiple concatenation, state complexity\n\n1. Introduction\nGiven formal languages L1 , L2 , . . . , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.\n\nJozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197\n\n2\n\nJ. Jir sek, G. Jir skov \n\nThe first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al. [8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state.\nThe concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found. The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4].\nCaron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata. They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages.\nIn this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1]. Our witness\nautomata A1 , A2 , . . . , Ak are defined over the alphabet {b, a1 , . . . , ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation. The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata. Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1]. In the case of k = 3, we show that the ternary alphabet is optimal.\nWe also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , . . . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k. For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case.\n2. Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7].\nThe size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .\n\nState Complexity of Multiple Concatenation\n\n3\n\nFor a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , . . . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , . . . , uk Lk }.\nA deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.\nAll deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function.\nWe usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}. Each input symbol a induces a transformation on Q = {q1 , q2 , . . . , qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . . . , q ) the transformation that maps qi to qi+1 for i = 1, . . . , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.\nNext, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . . , 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state.\nA state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.\nTwo states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ .\nA DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable. The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . . . , nk ) 7 max{sc(f (L1 , L2 , . . . , Lk )) | sc(Li ) ni for i = 1, 2, . . . , k}.\nA nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function. A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . . , qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . . , m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.\nLet N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ. The subset automaton D(N ) recognizes the language L(N ).\nThe reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by\n\n4\n\nJ. Jir sek, G. Jir skov \n\nswapping the roles of initial and final states, and by reversing all transitions.\nA subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R .\nWe use the following two simple observations to prove distinguishability of states\nin subset automata.\nLemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T . If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ).\nProof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R . It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .\n\nCorollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. \n3. Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.\nFor i = 1, 2, . . . , k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . . . , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . . . , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . . . , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and its set of final states is Fk .\nSince A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, . . . , k. We represent such a set by the k-tuple ({q}, S2 , S3 , . . . , Sk ), or\nmore often by (q, S2 , S3 , . . . , Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , . . . , Sk ) or (q, S2 a, S3 , . . . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .\nIt follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . . , Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition.\n\nState Complexity of Multiple Concatenation\n\n5\n\nDefinition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).\n\nNotice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , . . . , Ak as follows: for each i = 1, 2, . . . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .\nFor k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities.\nProposition 5. Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1\n\nn1 2n2 +n3 + +nk #τk \n\n3\nn1 2n2 +n3 + +nk .\n4\n\nProof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality.\n\nWe now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let\n\n Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,\n\n Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1\n\nwith fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.\n\nTheorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,\n\n(1)\n\n6\n\nJ. Jir sek, G. Jir skov \n\nand for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2\n\nVi = 2\n\n(Ui+1 + Vi+1 ).\n\n(2)\n(3)\n\nFinally, we have\n#τk = (n1 1)U2 + V2 .\n\n(4)\n\nProof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).\n\nLet fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).\n\nLet fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).\n\nLet us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].\n\nTo conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.\n\nState Complexity of Multiple Concatenation\n\n7\n\nProposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then\n\nV2 ,\nif j = 1;\n\nn1 ,\nif j = k = 2;\n\n (n 1)U + V + 1\n1\n2\n2\nsc(L) \n\nwith\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1\n\n(n1 1)U2 + V2 + Vi+1\n\nwith Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1.\nProof. First, let j = 1. Then we have S1 = {f1 } in each valid state (S1 , S2 , . . . , Sk ).\nIt follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 .\nNow, let j = k. Then all states (S1 , S2 , . . . , Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.\nFinally, let 2 j k 1. Then all states (S1 , S2 , . . . , Si 1 , {fi }, {si+1 }, , , . . . , )\nare equivalent to the state ({s1 }, {s2 }, . . . , {si 1 }, {fi }, {si+1 }, , , . . . , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , . . . , Si 1 , , , . . . , ) or of the\nform ({s1 }, {s2 }, . . . , {si 1 }, {fi }, Si+1 , Si+2 , . . . , Sk ). If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .\n\nExample 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .\n\n4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .\n\n8\n\nJ. Jir sek, G. Jir skov \na2\n\nA1\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na1\n\nf1 =n1\n\na1\na1\n\nA2\n\ns2 =1\n\na1\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).\n\nConstruct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2\n\nN\n\na2\n\ns1 =1\n\na1\n\n2\n\na2\na1\n\n...\n\na1\n\nn1 1\n\na2\na1\n\nf1 =n1\n\na1\na1\na1\n\ns2 =1\n\na2\na1\n\na2\n\n2\n\na1\n\na1\na2\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).\n\nLet us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.\n\nState Complexity of Multiple Concatenation\n\n9\n\nCase 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1\n\na\n\n1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2\n\nwhere the leftmost state is reachable as shown in Case 1.\naj 1\n\nCase 3: 2 j n1 1. Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b\n\na2\n\nN \n\ns1 =1\n\na1 , b\n\n2\n\na2 , b\na1\n\n...\n\na1\n\nn1 1\n\na2 , b\na1\n\nf1 =n1\n\na1\na2 , b\n\na1\na1 , b\n\na1\n\ns2 =1\n\na2 , b\n\na2\n\n2\n\na1 , b\n\na1 , b\n\n...\n\na2\n\nn2 1\n\na2\n\nf2 =n2\n\na2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ).\n\nAs shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na\n\na\n\na\n\na\n\na\n\n2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2} \n\n{2} \n{s2 }.\n\nNext, since n1 3, we have\nb\n\na\n\na\n\na\n\na\n\n1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1} \n\n{2} \n{s1 };\n\n10\n\nJ. Jir sek, G. Jir skov \nb\n\nnotice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb\n\nhave {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.\n\nWe use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}\n\nAi\n\nsi =1\n\nΣ \\ {ai }\nai , b\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\nai\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nFigure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , . . . , ak }.\n\nFirst, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial.\nThe next observation is crucial in what follows. It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }).\nMoreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.\nLemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw\n\nS\n(i) (si 1 , {si }) \n(si 1 , S);\n\nu\n\n(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.\n\nState Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }\n\nNi\n\nsi 1\n\nai 1 , b\n\nΣ \\ {ai 1 }\n\nai 1\n\n2\n\n11\n\nai 1\n\n...\n\nni 1 1\n\nΣ \\ {ai 1 }\n\nai 1\n\nfi 1\n\nai 1\nΣ \\ {ai }\n\nai 1\n\nΣ \\ {ai , b}\n\nsi\n\nΣ \\ {ai }\n\nai , b\n\nai\n\n2\n\nΣ \\ {ai }\n\nΣ \\ {ai }\n\n...\n\nai\n\nni 1\n\nai\n\nfi\n\nai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).\n\nProof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na\n\na\n\na\n\na\n\ni\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2}) \n\n(si 1 , {ni 1}) \n(si 1 , {fi }),\n\nso, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn\n\ni 1\nai 1\n\nam 1\n\ni\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),\n\nwhere the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .\n\nBy induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).\n\nNow, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.\n\n12\n\nJ. Jir sek, G. Jir skov \na2 , a3\n\nN\n\ns1\n\na2 , a3 , b\na1 , b\n\n2\n\na2 , a3 , b\na1\n\na1\na1\na1 , a3\n\ns2\n\nf1\na2 , a3 , b\na1 , a3 , b\n\na2 , b\n\n2\n\na1 , a3 , b\na2\n\n3\n\na2\n\na1 , a3 , b\na2\n\na2\na1 , a2\n\ns3\n\nf2\na1 , a3 , b\na1 , a2 , b\n\na1 , a2 , b\na3 , b\n\n2\n\na3\n\nf3\n\na3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3.\n\nTheorem 12. Let k 2 and ni 3 for i = 1, 2 . . . , k. Let Ai be the ni -state DFA\nfrom Figure 4. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ).\nProof. We first prove reachability. Let q = (j, S2 , S3 , . . . , Sk ) be a valid state.\nIf S2 = , then the state q = (j, , , . . . , ) is reached from the initial\nstate (s1 , , , . . . , ) by the string aj 1\n1 . Next, let = max{i 2 | Si = }.\nThen q = (j, S2 , S3 , . . . , S , , , . . . , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . . . , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , . . . , ) to\n(s1 , {s2 }, {s3 }, . . . , {s 1 }, {s }, , , . . . , ).\nNow, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . . , and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ).\nMoreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS . Since both a 1 and a perform identities on Q1 , Q2 , . . . , Q 2 , in\nthe subset automation D(N ) we have\nwS\n\n(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).\n\nState Complexity of Multiple Concatenation\n\n13\n\nNext, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1\n\n(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW\n\n(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na\n\na\n\nb\n\na\n\na\n\na\n\nb\n\na\n\na\n\n3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . . . , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, . . . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.\nThus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. \nNotice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states. We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability. To this aim, let k 2, ni 2 for i = 1, 2, . . . , k,\nand Σ = {b, a1 , a2 , . . . , ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},\n\n14\n\nJ. Jir sek, G. Jir skov \n\nthat is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }\n\nAi (i I)\n\nsi =1\n\nΣ \\ {ai , ak }\n\nai , ak\n\n2\n\nai , ak\n\nΣ \\ {ai , ak }\n\n...\n\nai , ak\n\nni 2\n\nΣ \\ {ai , ak }\n\nai , ak\n\nfi =ni\n\nak\n\nai\nΣ \\ {ai , b}\n\nAi (i J)\n\nsi =1\n\nΣ \\ {ai , b}\nai , b\n\n2\n\nΣ \\ {ai , b}\n\nΣ \\ {ai , b}\nai , b\n\n...\n\nai , b\n\nni 2\n\nai , b\n\nfi =ni\n\nb\n\nai\nΣ \\ {ak , b}\n\nAk\n\nsk =1\n\nΣ \\ {ak , b}\n\nak , b\n\n2\n\nak , b\n\nΣ \\ {ak , b}\n\n...\n\nak , b\n\nnk 2\n\nΣ \\ {ak , b}\n\nak , b\n\nfk =nk\n\nak\n\nb\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).\n\n each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.\n\nState Complexity of Multiple Concatenation\n\n15\n\nConstruct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . . , Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . . , k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk .\nTheorem 13. Let k 2 and ni 2 for i = 1, 2, . . . , k. Let A1 , A2 , . . . , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).\nProof. First, notice that Lemma 11 still holds for automata A1 , A2 , . . . , Ak 1 since\nthe transitions on a1 , a2 , . . . , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.\nLet ({j}, S2 , S3 , . . . , Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . . . , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12.\nNow, let Sk = . Then the state (s1 , {s2 }, {s3 }, . . . , {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ). However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components.\nLet u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak . Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . . , {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . . , {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . . , Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 .\nTo prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb\n\na\n\na\n\nb\n\na\n\na\n\na\n\na\n\nb\n\na\n\na\n\n5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1\n\n{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.\n\nIn the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.\n\n5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example.\n\n16\n\nJ. Jir sek, G. Jir skov \na2 , a3 , a4 , b\n\nb\n\nA1\n\ns1\n\na5\n\n2\n\nf1\n\nN\n\na2 , a3 , a4 , b\na1 , a5\n\ns1\n\na1 , a3 , a4 , a5\n\ns2\n\na1 , a3 , a4 , a5 , b\n\na2 , b\na1 , a2 , a4 , b\n\ns3\n\n2\n\nf3\n\na1 , a2 , a4 , b\na3 , a5\n\ns3\n\na1 , a2 , a3 , a5\n\ns4\n\nf4\n\ns4\n\na4 , b\n\ns5\n\nf3\n\na1 , a2 , a4 , a5 , b\n\nf4\n\na1 , a2 , a3 , a4 , a5\n\na1 , a2 , a3 , a4\n\nf5\n\na3 , a5\n\na1 , a2 , a3 , a5 , b\n\na4 , b\n\ns5\n\na1 , a2 , a4 , a5 , b\n\na1 , a2 , a3 , a5 , b\n\na4\n\nA5\n\n2\na3\n\na3 , a5\n\nA4\n\na2 , a3 , a4 , a5 , b\n\nf2\n\na2\n\nA3\n\nf1\n\na1 , a3 , a4 , a5 , b\na2 , b\n\ns2\n\nf2\n\na1 , a5\n\na1\n\na1 , a5\n\nA2\n\n2\n\na2 , a3 , a4 , a5 , b\n\na5 , b\n\nf5\n\nb\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.\n\nState Complexity of Multiple Concatenation\n\n17\n\nExample 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb\n\nb\n\nb\n\nb\nb\nA\n\ns1 =1\n\na\n\na\n\n2\n\n3\n\n...\n\na\n\nn1 1\n\na\n\nf1 =n1\n\na\n\nb\n\nB\n\na\n\ns2 =1\n\na\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\n\na, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.\n\nFirst, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na\n\nbm 2\n\n(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N . By Proposition 8,\nan upper bound is V2 = 2n2 1 .\nFinally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial. Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 . Let |S| 1. There are three cases to consider.\n\n18\n\nJ. Jir sek, G. Jir skov \n\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na\n\n(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na\n\nbn2\n\nCase 2.b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.\nCase 2.c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.\nm 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2.a.\nCase 3: 2 j n1 1. Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2.\nThis proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states. There are two cases to consider.\nCase 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N .\nCase 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 . The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 . Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise.\nFirst, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A.\nIt follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.\nNow, let s2 an1 = s2 . Then we have\nan1 1\n\na\n\n(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1\n\nb\n\nan1 1\n\n(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.\n\nState Complexity of Multiple Concatenation\n\n19\n\nHence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states).\nTherefore, in what follows we assume that k 3.\nWe use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. The idea is as follows.\nThe transitions on input symbols a1 , a2 , . . . , ak 1 in automata A1 , A2 , . . . , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, . . . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.\nTo this aim, let k 3 and Σ = {b, a1 , a2 , . . . , ak 1 } be a k-letter alphabet.\nLet n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1. For i = 1, 2, . . . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, . . . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, . . . , ni ), b : ({2, 3, . . . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, . . . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.\nb\nb\n\nb\n\nb\nb\n\nAi\n(i<k)\n\nsi =1\n\nai\n\n2\n\nai\n\n3\n\nsk =1\n\n...\n\nai\n\nni 1\n\nai\n\nfi =ni\n\nai\n\nb\n\nAk\n\nai\n\nak 1\n\n2\n\nak 1 , b\n\n3\n\nak 1 , b\n\n...\n\nak 1 , b\n\nnk 1\n\nak 1 , b\n\nfk =nk\n\nak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.\n\n20\n\nJ. Jir sek, G. Jir skov \n\nTheorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . . . , k 1.\nLet A1 , A2 , . . . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , . . . , ak 1 }. Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above.\nThen all valid states are reachable and pairwise distinguishable in D(N ).\nProof. Consider a valid state q = (j, S2 , . . . , Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , . . . , ak 1 in A1 , A2 , . . . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , . . . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.\nNow let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ). Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . . , sk 2 , we reach (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS .\nNext, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi . Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, . . . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, . . . , {sk 2 }, Sk 1 , Sk ) by wSk 1 . The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let p = (S1 , S2 , S3 , . . . , Sk ) and q = (T1 , T2 , T3 , . . . , Tk )\nbe two distinct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .\nLet Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . . , k.\nLet us show that there is a string that sends p and q to two states which differ in si+1 .\nWithout loss of generality, we have s Si \\ Ti . First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states\n\n(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )\n\n(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )\n\nwhere S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of\n\nthe resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired\n\nresult. Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, Ti+1\n, . . . , Tk )\n\nwhere q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.\n\nState Complexity of Multiple Concatenation\n\n21\n\nCase 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 . Thus after reading ai+1 b, we get states\n\n( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )\n\n({s1 }, {s2 }, {s3 }, . . . , {si 1 },\n\n{si }\n\n, {si+1 }, Ti+2\n, . . . , Tk ).\n\nFinally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .\n\nSince the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.\n\nWe conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3.\nTheorem 17. The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal.\nProof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3. Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . . , ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . . , Ak 1 must\nhave one final state, and it must be different from the initial state.\nConstruct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.\nNotice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 .\nIf both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them.\nIf both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw \n\nw \n\nfrom the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw \n\nw \n\nthen it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.\n\n22\n\nJ. Jir sek, G. Jir skov \n\nHence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 .\nNext, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }. Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 . We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig. 11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .\nNext, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 .\nHence both a and b perform permutations on Q3 , thus resulting in a contradiction.\nb\nA2\n\n0\n\np\n\na\n\nq\nb\n\nf2\n\nFigure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .\n\n(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig. 12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b. Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 .\nThis means that s3 b = s3 . Hence b is a permutation on Q3 . Let r Q2 \\ {s2 b, f2 }.\nThen the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 . Thus both a and b perform a permutation\nin A2 , which is a contradiction.\n\nNotice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,\n\nState Complexity of Multiple Concatenation\n\n23\nb\n\nA2\n\np\n\n0\n\nq\n\na\n\nb\n\nf2\n\nFigure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .\n\nand the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc\n\nc\n\na2\n\nb\nA1\n\ns1\n\nf1\n\nA2\n\ns2\n\nc\n\ns3\n\nb\na3\n\na4\nf3\n\nA4\n\nc\n\nc\n\ns4\n\ns5\n\nb\na5\n\nc\na4\n\nf4\n\nb\n\nb\n\na5\nA5\n\nf2\n\nb\n\nb\n\na3\nA3\n\nc\na2\n\nb\nc\n\nb\n\nb\n\na5\nf5\n\nA6\n\ns6\n\nc\na5\n\nf6\n\nFigure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.\n\nConstruct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has\n\n24\n\nJ. Jir sek, G. Jir skov \n\nto be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .\n6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , . . . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k. Let us start\nwith the following example.\nExample 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end.\nLet us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state. Let |S| 2 and 1 S. Let m = min(S \\ {1}).\nSet S = abm 2 (S \\ {1, m}). Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2\n\na\n\n{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.\n\nWe now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end.\nTheorem 19. Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k.\nLet A1 , A2 , . . . , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.\nProof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . . . , k 1 and σ {a, b}, by making states f1 , f2 , . . . , fk 1 non-final, and\nstates s2 , s3 , . . . , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them. Let N be the resulting NFA;\nsee Figure 16 for an illustration.\nIn the subset automaton D(N ), each state (j, , , . . . , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . . . , ) by bj 1 , and (f1 , {s2 }, , , . . . , ) is\nreached from (f1 1, , , . . . , ) by b. Starting with the state f1 , the NFA N accepts\na, b\n\nN\n\n1\n\na\n\n2\n\na, b\n\n3\n\na, b\n\n...\n\na, b\n\nn 1\n\na, b\n\nn\n\nFigure 14: A binary NFA N such that every set {1} S is reachable in D(N ).\n\nState Complexity of Multiple Concatenation\n\n25\n\na, b\n\na\n\nA1\n\ns1 =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn1 2\n\na, b\n\nn1 1\n\nb\n\nf1 =n1\na, b\n\nb\n\nA2\n\na\n\ns2 =1\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nn2 2\n\na, b\n\nn2 1\n\na, b\n\nf2 =n2\na, b\n\nAi\n(i>2)\n\nsi =1\n\na, b\n\na, b\n\n2\n\n3\n\na, b\n\n...\n\na, b\n\nni 2\n\na, b\n\nni 1\n\na, b\n\nfi =ni\n\nFigure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation.\n\na, b\na\nN\n\ns1 =1\n\na, b\n\na, b\n\nb\n\nb\n\ns2 =1\n\n2\n\na\n\n3\n\nb\n\nf1 =4\na, b\n\na, b\n2\n\na, b\n\n3\n\na, b\n\n4\n\na, b\n\na, b\n\n2\n\na, b\n\n3\n\na, b\n\nf3 =4\n\na, b\n\na, b\n\n2\n\na, b\n\n6\n\n5\na, b\n\na, b\ns4 =1\n\na, b\n\na, b\n\na, b\ns3 =1\n\nf2 =5\n\n3\n\na, b\n\nf4 =4\n\na, b\n\n5\n\nFigure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\n26\n\nJ. Jir sek, G. Jir skov \n\nall strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .\n\nOur next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case.\nTheorem 20. Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . . , k. There\nexist ternary DFAs A1 , A2 , . . . , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states.\nProof. Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . . , n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , . . . , Sk ). Each such state is sent to the state (j, S2 , S3 , . . . , Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable. This gives the desired lower bound.\n\n7. Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5.4 and 5.5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller. Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.\nRecall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . . , q 1 and a cycle p0 , p1 , . . . , pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6].\nLet n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = 1.\nThen g(n1 , n2 , . . . , nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . . , xk . Let us star with the following observation.\n\nState Complexity of Multiple Concatenation\n\n27\na, b\n\nc\na\nN\n\ns1 =1\n\na, b\nc\n\nc\n\nb\n\nc\n\ns2 =1\n\na\n\nc\n\na, b\nc\n\n2\nb\n\na, b\n\n2\nc\n\ns3 =1\n\na, b\n\ns4 =1\n\na, b\n\nc\na, b\n\n2\n\nb\nc\n\nf1 =4\n\nc\n\na, b\n\nc\n\na, b\n\n3\n\na, b\n\na, b\n\n3\n\na, b\n\na, b\n\n4\n\nf2 =5\n\na, b\n\na, b\nc\n\n6\n\na, b\n\nc\n\nf3 =4\n\na, b\nc\n\nf4 =4\n\na, b\n\n5\n\nc\n\nc\n3\n\nc\n\na, b\n\nc\n\n2\n\nc\n\n3\n\nc\na, b\n\n5\n\na, b\n\nFigure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.\n\nLemma 21. Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.\n\nLet f (n1 , n2 , . . . , nk ) = g(n1 , n2 , . . . , nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result.\nTheorem 22. Let A1 , A2 , . . . , Ak be unary cyclic automata with n1 , n2 , . . . , nk\nstates, respectively. Let d = gcd(n1 , n2 , . . . , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , . . . , ndk ) k + 1,\nand this upper bound is tight.\nProof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ). By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we have am L if and only if am+d L.\nWe can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8]. Let m d f ( nd1 , nd2 , . . . , ndk ) k + 1.\nIf am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi\n\n28\n\nJ. Jir sek, G. Jir skov \n\nand xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (\n\nn1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd\n\nn1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd\n\nd f(\n\nSince x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(\n\nnk\nn1 n2\n, , . . . , ) + 1,\nd d\nd\n\nand therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and only if\nd f (\n\nn1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd\n\nfor some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(\n\nn1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1\n\nn2\n\nnk\n\nn1\n\nn2\n\nnk\n\nBy Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.\n\nBy [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.\n\nState Complexity of Multiple Concatenation\n\n29\n\nCorollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .\n\nIn the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively.\nExample 24. Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j).\nAs shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states. By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206.\nNevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.\nOur next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages.\nIn such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1.\nBy [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.\nIn both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this\n\n30\n\nJ. Jir sek, G. Jir skov \n\nnumber by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <\n\n2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3\n\nNow, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.\n\nMotivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple. We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound.\nTheorem 25. For i = 1, 2, . . . , k, let Ai be a unary DFA of size (λi , i ). For a\nnon-empty set I = {i1 , i2 , . . . , i } {1, 2, . . . , k}, let\ndI = gcd(λi1 , λi2 , . . . , λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . . , ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . . . , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . . . , k}}.\nProof. Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .\nI {1,2,...,k} j I\n/\n\ni I\n\nState Complexity of Multiple Concatenation\n\n31\n\nQ\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n( \n\n1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.\n\nThe above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open.\n8. Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . . . , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . . . , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , . . . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component. The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.\nThen we provided special binary witnesses for the concatenation of two languages.\nUsing our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].\nFor k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1].\nWe also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively. This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . . , nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.\n\n32\n\nJ. Jir sek, G. Jir skov \n\nFinally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5.4]. We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails.\nSome problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, . . . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2. Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states.\nWe proved the optimality of a ternary alphabet for the concatenation of three\nlanguages. However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal?\nNext, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2. What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ?\nFinally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails.\nThe tightness of this upper bound remains open."]}
{"method": "hybrid", "num_chunks": 1023, "avg_chunk_len": 71.36265884652981, "std_chunk_len": 132.54199597684072, "max_chunk_len": 790, "min_chunk_len": 1, "total_chars": 73004, "compression_ratio": 1.0247931620185196, "chunks": ["Accepted for publication in the Journal of Automata, Languages and Combinatorics\nFinal version created on November 7, 2025", "arXiv:2511.03814v1 [cs.FL] 5 Nov 2025", "STATE COMPLEXITY OF MULTIPLE CONCATENATION", "Jozef Jir sek\n(A)", "(A,B)", "Galina Jir skov", "(C,D)", "Institute of Computer Science, P. J. af rik University\nJesenn 5, 040 01 Ko ice, Slovakia\njozef.jirasek@upjs.sk", "(C)", "Mathematical Institute, Slovak Academy of Sciences\nGre kova 6, 040 01 Ko ice, Slovakia\njiraskov@saske.sk", "ABSTRACT\nWe describe witness languages meeting the upper bound on the state complexity of\nthe multiple concatenation of k regular languages over an alphabet of size k + 1 with\na significantly simpler proof than that in the literature. We also consider the case\nwhere some languages may be recognized by two-state automata. Then we show that\none symbol can be saved, and we define witnesses for the multiple concatenation of k\nlanguages over a k-letter alphabet.", "This solves an open problem stated by Caron et al. [2018, Fundam. Inform.", "160, 255 279]. We prove that for the concatenation of three\nlanguages, the ternary alphabet is optimal. We also show that a trivial upper bound\non the state complexity of multiple concatenation is asymptotically tight for ternary\nlanguages, and that a lower bound remains exponential in the binary case.", "Finally,\nwe obtain a tight upper bound for unary cyclic languages and languages recognized by\nunary automata that do not have final states in their tails.", "Keywords: regular languages, multiple concatenation, state complexity", "1. Introduction\nGiven formal languages L1 , L2 , . . . , Lk over an alphabet Σ, their concatenation is the\nlanguage L1 L2 Lk = {u1 u2 uk | ui Li for i = 1, 2, . . . , k}. Here we consider\nthe case where all languages are regular and ask the question of how many states\nare sufficient and necessary in the worst case for a deterministic finite automaton\nto recognize their concatenation assuming that each Li is recognized by an ni -state\ndeterministic finite automaton.\nA preliminary version of this paper appeared in Proc. DCFS 2020, LNCS vol. 12442, pp. 78 90.\n(B) Research supported by VEGA grant 1/0350/22.\n(D) Research supported by VEGA grant 2/0096/23.", "Jozef Jir sek: 0000-0003-4822-230X, Galina Jir skov : 0000-0001-9817-8197", "2", "J. Jir sek, G. Jir skov", "The first results for the concatenation of two regular languages were obtained by\nMaslov [5] in 1970. In particular, he described binary witnesses meeting the upper\nbound n1 2n2 2n2 1 . In 1994 Yu et al.", "[8] proved that this upper bound cannot be\nmet if the first language is recognized by a minimal deterministic finite automaton\nthat has more than one final state. The concatenation of three and four regular languages was considered by sik et\nal. [2] in 2009, where the witnesses for the concatenation of three languages over a\nfive-letter alphabet can be found.", "The rather complicated expression for the upper\nbounds for the concatenation of k languages, as well as witnesses over a (2k 1)-letter\nalphabet were given by Gao and Yu [4]. Caron et al. [1] presented recursive formulas for the upper bounds, and described\nwitnesses over a (k + 1)-letter alphabet using Brzozowski s universal automata.", "They\nalso showed that to meet the upper bound for the concatenation of two or three\nlanguages, the binary or ternary alphabet, respectively, is enough, and they conjectured that k symbols could be enough to describe witnesses for the concatenation of k\nlanguages. In this paper, we study in detail the state complexity of multiple concatenation\nof k regular languages. We first describe witnesses over an alphabet consisting\nof k + 1 symbols with a significantly simpler proof than that in [1].", "Our witness\nautomata A1 , A2 , . . .", ", Ak are defined over the alphabet {b, a1 , . . .", ", ak }. Each ai performs the circular shift in Ai and the identity in all the other automata. These k\npermutation symbols are used to get the reachability of all so-called valid states in a\nDFA for concatenation.", "The symbol b performs a contraction in each Ai and assures\nthe distinguishability of all valid states almost for free. However, the proof requires\nthat each Ai has at least three states. With a slightly more complicated proof, we\nalso solve the case that includes two-state automata.", "Then we describe special binary\nwitnesses for the concatenation of two languages. We combine our ideas used for\nthe (k + 1)-letter alphabet and those for binary witnesses to describe witnesses for\nmultiple concatenation over a k-letter alphabet, which solves an open problem stated\nby Caron et al. [1].", "In the case of k = 3, we show that the ternary alphabet is optimal. We also examine multiple concatenation on binary, ternary, and unary languages. We show that in the binary case, the lower bounds remain exponential in\nn2 , n3 , .", ". . , nk , and in the ternary case, the trivial upper bound n1 2n2 +n3 + +nk can\nbe met up to some multiplicative constant depending on k.", "For unary languages, we\nuse Frobenius numbers to get a tight upper bound for cyclic languages, or languages\nrecognized by automata that do not have final states in their tails. We also consider\nthe case with final states in tails, and provide upper and lower bounds for multiple\nconcatenation in such a case. 2.", "Preliminaries\nWe assume that the reader is familiar with basic notions in automata and formal\nlanguage theory. For details and all unexplained notions, we refer the reader to [7]. The size of a finite set S is denoted by |S|, and the set of all its subsets by 2S .", "State Complexity of Multiple Concatenation", "3", "For a finite non-empty alphabet of symbols Σ, the set of all strings over Σ,\nincluding the empty string ε, is denoted by Σ . A language is any subset\nof Σ . The multiple concatenation of k languages L1 , L2 , .", ". . , Lk is the language L1 L2 Lk = {u1 u2 uk | u1 L1 , u2 L2 , .", ". . , uk Lk }.", "A deterministic finite automaton (DFA) is a quintuple A = (Q, Σ, , s, F ) where Q\nis a non-empty finite set of states, Σ is a non-empty finite alphabet of input symbols,\n : Q Σ Q is the transition function, s Q is the initial state, and F Q is the\nset of final (accepting) states. The transition function can be naturally extended to\nthe domain Q Σ . The language recognized (accepted) by the DFA A is the set of\nstrings L(A) = {w Σ | s w F }.", "All deterministic finite automata in this paper are assumed to be complete; that\nis, the transition function is a total function. We usually omit , and write qa instead of q a. Next, for a subset S of Q and\na string w, let Sw = {qw | q S} and wS = {q | qw S}.", "Each input symbol a induces a transformation on Q = {q1 , q2 , . . .", ", qn } given by q 7 qa. We denote\nby a : (q1 , q2 , . .", ". , q ) the transformation that maps qi to qi+1 for i = 1, . .", ". , 1, the\nstate q to q1 , and fixes any other state in Q. In particular, (q1 ) denotes the identity.", "Next, we denote by a : (q1 q2 q ) the transformation that maps qi to qi+1\nfor i = 1, 2, . . .", ", 1 and fixes any other state. Finally, we denote by a : (S qi ) the\ntransformation that maps each q S to qi and fixes any other state. A state q Q is reachable in the DFA A if there is a string w Σ such that q = sw.", "Two states p and q are distinguishable if there is a string w such that exactly one of\nthe states pw and qw is final. A state q Q is a dead state if qw \n/ F for every\nstring w Σ . A DFA is minimal (with respect to the number of states) if all its states are\nreachable and pairwise distinguishable.", "The state complexity of a regular language L, sc(L), is the number of states in the minimal DFA recognizing L. The\nstate complexity of a k-ary regular operation f is a function from Nk to N given\nby (n1 , n2 , . .", ". , nk ) 7 max{sc(f (L1 , L2 , . .", ". , Lk )) | sc(Li ) ni for i = 1, 2, . .", ". , k}. A nondeterministic finite automaton (NFA) is a quintuple N = (Q, Σ, , I, F )\nwhere Q, Σ, and F are the same as for a DFA, I Q is the set of initial\nstates, and : Q (Σ {ε}) 2Q is the transition function.", "A string w in Σ \nis accepted by the NFA N if w = a1 a2 am where ai Σ {ε} and a sequence of states q0 , q1 , . . .", ", qm exists in Q such that q0 I, qi+1 qi ai+1\nfor i = 0, 1, . . .", ", m 1, and qm F . The language recognized by the NFA N is the\nset of strings L(N ) = {w Σ | w is accepted by N }. For p, q Q and a Σ {ε},\nwe say that a triple (p, a, q) is a transition in N if q p a.", "Let N = (Q, Σ, , I, F ) be an NFA. For a set S Q, let E(S) denote\nthe ε-closure of S; that is, the set of states {q | q is reached from a state\nin S through 0 or more ε-transitions}. The subset automaton of the NFA N\nis the DFA D(N ) = (2Q , Σ, , E(I), F ) where F = {S 2Q | S F = }\nand S a = q S E(q a) for each S 2Q and each a Σ.", "The subset automaton D(N ) recognizes the language L(N ). The reverse of the NFA N is the NFA N R = (Q, Σ, R , F, I) where the transition\nfunction is defined by q R a = {p Q | q p a}; that is, N R is obtained from N by", "4", "J. Jir sek, G. Jir skov", "swapping the roles of initial and final states, and by reversing all transitions. A subset S of Q is reachable in N if there is a string w in Σ such that S = I w,\nand it is co-reachable in N if it is reachable in the reverse N R . We use the following two simple observations to prove distinguishability of states\nin subset automata.", "Lemma 1. Let N = (Q, Σ, , I, F ) be an NFA without ε-transitions. Let S, T Q\nand q S \\ T .", "If the singleton set {q} is co-reachable in N , then S and T are\ndistinguishable in the subset automaton D(N ). Proof. Since the singleton set {q} is co-reachable in N , there is a string w Σ which\nsends the set of final states F to {q} in the reversed automaton N R .", "It follows that\nthe string wR is accepted by N from the state q, and it is rejected from any other\nstate. Thus, the string wR is accepted by D(N ) from S and rejected from T .", "Corollary 2. If for each state q of an NFA N , the singleton set {q} is co-reachable\nin N , then all states of the subset automaton D(N ) are pairwise distinguishable. 3.", "Multiple Concatenation: Upper Bound\nIn this section, we recall the constructions of ε-NFAs and NFAs for multiple concatenation, as well as the known upper bounds. We also provide a simple alternative\nmethod to get upper bounds. In the last part of this section, we consider the case\nwhen some of given automata have just one state.", "For i = 1, 2, . . .", ", k, let Ai = (Qi , Σ, i , si , Fi ) be a DFA, and assume that Qi Qj = \nif i = j. Then the concatenation L(A1 )L(A2 ) L(Ak ) is recognized by an NFA\nN = (Q1 Q2 Qk , Σ, , s1 , Fk ), where for each i = 1, 2, . .", ". , k, each q Qi , and\neach a Σ, we have q a = {q i a} and for each i = 1, 2, . .", ". , k 1 and each q Fi ,\nwe have q ε = {si+1 }, that is, the NFA N is obtained from the DFAs A1 , A2 , . .", ". , Ak\nby adding the ε-transition from each final state of Ai to the initial state si+1 of Ai+1\nfor i = 1, 2, . .", ". , k 1; the initial state of N is s1 , and its set of final states is Fk . Since A1 is a complete DFA, in the corresponding subset automaton D(N ), each\nreachable subset is of the form {q} S2 S3 Sk where q S1 and Si Qi\nfor i = 2, 3, .", ". . , k.", "We represent such a set by the k-tuple ({q}, S2 , S3 , . . .", ", Sk ), or\nmore often by (q, S2 , S3 , . . .", ", Sk ), and with this representation, it is not necessary to\nhave the state sets disjoint. Nevertheless, since we sometimes use special properties\nof the NFA N , we keep in mind that this k-tuple represents the union of appropriate\nset of states of the corresponding DFAs. We usually denote all transition functions\nby , and simply write (qa, S2 , S3 , .", ". . , Sk ) or (q, S2 a, S3 , .", ". . , Sk ); that is, applying a\nto the i-th component means that we use the transition function i .", "It follows from the construction of the NFA N that if Si Fi = then si+1 Si+1 ,\nand if Si = , then Si+1 = in any reachable state (S1 , S2 , . . .", ", Sk ) of the subset\nautomaton D(N ). The states satisfying the above mentioned properties are called\nvalid in [1]; let us summarize the three properties in the next definition.", "State Complexity of Multiple Concatenation", "5", "Definition 3. A state (S1 , S2 , . . . , Sk ) of the subset automaton D(N ) is valid if\n(I) |S1 | = 1,\n(II) if Si = and i k 1, then Si+1 = ,\n(III) if Si Fi = and i k 1, then si+1 Si+1 .\nSince each reachable state of D(N ) is valid, we have the next observation.\nProposition 4. An upper bound on sc(L(A1 )L(A2 ) L(Ak )) is given by the number\nof valid states in the subset automaton D(N ).", "Notice that, to reach as many valid states as possible, each automaton Ai\nwith i k 1 should have exactly one final state fi , that is, we have Fi = {fi }. Moreover, if Ai has at least two states, then we should have si = fi . If this is the case for\nall Ai , then we can construct an NFA N for the concatenation L(A1 )L(A2 ) L(Ak )\nfrom the DFAs A1 , A2 , .", ". . , Ak as follows: for each i = 1, 2, .", ". . , k 1, each state q Qi ,\nand each symbol a Σ such that q i a = fi , we add the transition (q, a, si+1 ); the\ninitial state of N is s1 , and its unique final state is fk .", "For k = 2, an upper bound on the number of valid states is (n1 1)2n2 + 2n2 1 [8],\nwhich is the sum of the number of states (q, S2 ) with q = f1 and S2 Q2 and the\nnumber of states (f1 , S2 ) with s2 S2 . For k 3, we have the following inequalities. Proposition 5.", "Let k 3 and #τk denote the number of valid states. Then\n1\n2k 1", "n1 2n2 +n3 + +nk #τk", "3\nn1 2n2 +n3 + +nk .\n4", "Proof. Every state (S1 , S2 , . . . , Sk ) with si Si for i = 2, 3, . . . , k is a valid state. This\ngives the left inequality. On the other hand, every state (S1 , S2 , . . . , Sk ) with f2 S2\nand s3 \n/ S3 is not valid, which gives the right inequality.", "We now provide a simple alternative method for obtaining an upper bound on the\nnumber of valid states. To this aim let", "Ui be the number of tuples (Si , Si+1 , . . . , Sk ) such that for fixed S1 , S2 , . . . , Si 1", "with fi 1 \n/ Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid,", "Vi be the number of tuples (Si , Si+1 , . . . , Sk ) such that for a fixed S1 , S2 , . . . , Si 1", "with fi 1 Si 1 the state (S1 , . . . , Si 1 , Si , Si+1 , . . . , Sk ) is valid.\nThen we have the next result.", "Theorem 6. Let k 2, ni 2 for i = 1, 2, . . . , k, and Ai = (Qi , Σ, , si , {fi })\nbe an ni -state DFA with si = fi . Let Ui and Vi be as defined above, and #τk be the\nnumber of valid states in the subset automaton D(N ) accepting L(A1 )L(A2 ) L(Ak ).\nThen\nUk = 2nk and Vk = 2nk 1 ,", "(1)", "6", "J. Jir sek, G. Jir skov", "and for i = 2, 3, . . . , k 1,\nUi = 1 + (2ni 1 1)Ui+1 + 2ni 1 Vi+1 ,\nni 2", "Vi = 2", "(Ui+1 + Vi+1 ).", "(2)\n(3)", "Finally, we have\n#τk = (n1 1)U2 + V2 .", "(4)", "Proof. If fk 1 \n/ Sk 1\n, then Sk may be an arbitrary subset of Qk . If fk 1 Sk 1\n,\nthen Sk must contain sk . This gives (1).", "Let fi 1 \n/ Si 1\n. Then we have just one tuple with Si = , namely, ( , , . . . , ),\nni\nthen (2 1)Ui+1 tuples with fi \n/ Si and Si non-empty, and 2ni 1 Vi+1 tuples\nwith fi Si final. This gives (2).", "Let fi 1 Si 1\n. Then si Si . We have (2ni 2)Ui+1 tuples with si Si\nni 2\nand fi \n/ Si , and 2\nVi+1 tuples with si Si and fi \n/ Si . This gives (3).\nFinally, we have (n1 1) possibilities for S1 to be non-final singleton set, and one,\nnamely, S1 = {f1 }, to be final. This gives (4).", "Let us illustrate the above result in the following example.\nExample 7. Let k = 3 and n1 , n2 , n3 2. Then\nU3 =2n3 and V3 = 2n3 1 ,\nU2 =1 + (2n2 1 1)U3 + 2n2 1 V3 = 1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ,\nV2 =2n2 2 (U3 + V3 ) = 2n2 2 (2n3 + 2n3 1 )\n#τk =(n1 1)U2 + V2 =\n(n1 1)(1 + (2n2 1 1)2n3 + 2n2 1 2n3 1 ) + 2n2 2 (2n3 + 2n3 1 ) =\nn1 (1 + 2n2 +n3 1 2n3 + 2n2 +n3 2 ) 1 2n2 +n3 1 + 2n3 2n2 +n3 2 +\n2n2 +n3 2 + 2n2 +n3 3 =\n3\n3\nn1 (1 + 2n2 +n3 2n3 ) 2n2 +n3 + 2n3 1,\n4\n8\nwhich is the same as in [1, Example 3.6].", "To conclude this section, let us consider also the case when some automata have just\none state. If this state is non-final, then the resulting concatenation is empty. Thus,\nassume that all one-state automata recognize Σ , so consist of one initial and final\nstate fi . Then we construct an NFA N accepting the language L(A1 )L(A2 ) L(Ak )\nas described above. Let D(N ) be the corresponding subset automaton. We represent\nis states by k-tuples ({q}, S2 , S3 , . . . , Sk ) where q Q1 and Si Qi . Moreover,\nif ni = 1, then Si = {fi }. If ni 2 and i < k, then to get maximum number of valid\nreachable sets, we must have Fi = {fi } and si = fi . The next observation provides\nan upper bound in the case when exactly one of given DFAs has one state.", "State Complexity of Multiple Concatenation", "7", "Proposition 8. Let k 2, j {1, 2, . . . , k}, nj = 1, and ni 2 if i = j.\nFor i = 1, 2, . . . , k, let Ai be an ni -state DFA and L = L(A1 )L(A2 ) L(Ak ). Let Ui\nand Vi be given by expressions (2)-(3). Then", "V2 ,\nif j = 1;", "n1 ,\nif j = k = 2;", "(n 1)U + V + 1\n1\n2\n2\nsc(L)", "with\nU\n=\n2nk 1 1 and Vk 1 = 2nk 1 2 , if j = k 3;\nk 1", "(n1 1)U2 + V2 + Vi+1", "with Uj 1 = 2nj 1 1 and Vj 1 = 2ni 1 2 , if 2 j k 1. Proof. First, let j = 1.", "Then we have S1 = {f1 } in each valid state (S1 , S2 , . . .", ", Sk ). It follows that the number of valid states is V2 with Uk = 2nk and Vk = 2nk 1 . Now, let j = k.", "Then all states (S1 , S2 , . . .", ", Sk 1 , {fk }) are equivalent to a final sink\nstate. If Sk = , then fk 1 \n/ Sk 1 . This results in an upper bound (n1 1)U2 +V2 +1\nwith Uk 1 = 2nk 1 1 and Vk 1 = 2nk 1 2 if k 3 and (n1 1) + 1 if k = 2.", "Finally, let 2 j k 1. Then all states (S1 , S2 , . .", ". , Si 1 , {fi }, {si+1 }, , , . .", ". , )\nare equivalent to the state ({s1 }, {s2 }, . .", ". , {si 1 }, {fi }, {si+1 }, , , . .", ". , ) since\nwe have a loop on each input symbol in the state fi and therefore every string accepted by N from a state in Q1 Q2 Qi 1 is accepted\nalso from fi . It follows that the reachable and pairwise distinguishable valid\nstates of D(N ) are either of the form (S1 , S2 , .", ". . , Si 1 , , , .", ". . , ) or of the\nform ({s1 }, {s2 }, .", ". . , {si 1 }, {fi }, Si+1 , Si+2 , .", ". . , Sk ).", "If Si = , then Si 1 does not\ncontain fi , so the number of valid states of the first form is given by (ni 1)U2 + V2\nwith Ui 1 = 2ni 1 1 and Vi 1 = 2ni 1 2 . The number of valid states of the second\nform is given by Vi+1 .", "Example 9. Let k = 4, n3 = 1, and n1 , n2 , n4 2. Then number of valid\nstates (S1 , S2 , , ) is (n1 1)U2 + V2 where U2 = 2n2 1 and V2 = 2n2 2 . Next,\nthe number of valid states ({s1 }, {s2 }, {f3 }, S4 ) is V4 = 2n4 1 . This gives an upper\nbound (n1 1)2n2 1 + 2n2 2 + 2n4 1 for concatenation of four languages, the third\nof which is Σ .", "4. Matching Lower Bound: (k + 1)-letter Alphabet\nIn this section, we describe witness languages meeting the upper bound on the state\ncomplexity of multiple concatenation of k regular languages over a (k + 1)-letter\nalphabet with a significantly simpler proof than that in [1, Section 4, pp. 266 271].\nWe use these witnesses in the next section to describe witness languages over a k-letter\nalphabet. Let us start with the following example.\nExample 10. Let n1 , n2 3. Consider DFAs A1 and A2 over {a1 , a2 } shown in\nFigure 1. The symbol a1 performs the circular shift in A1 , and the identity in A2 .\nSymmetrically, the symbol a2 performs the identity in A1 , and the circular shift in A2 .", "8", "J. Jir sek, G. Jir skov \na2", "A1", "a2", "s1 =1", "a1", "2", "a2", "a2\na1", "...", "a1", "n1 1", "a1", "f1 =n1", "a1\na1", "A2", "s2 =1", "a1\na2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 1: DFAs A1 and A2 with all valid states reachable in D(N ).", "Construct the NFA N recognizing the language L(A1 )L(A2 ) from the DFAs A1\nand A2 by adding the transitions (f1 , a2 , s2 ) and (f1 1, a1 , s2 ), by making the state f1\nnon-final and state s2 non-initial. The NFA N is shown in Figure 2.\na2", "N", "a2", "s1 =1", "a1", "2", "a2\na1", "...", "a1", "n1 1", "a2\na1", "f1 =n1", "a1\na1\na1", "s2 =1", "a2\na1", "a2", "2", "a1", "a1\na2", "...", "a2", "n2 1", "a2", "f2 =n2", "a2\nFigure 2: The NFA N recognizing the language L(A1 )L(A2 ).", "Let us show that each valid state (j, S) is reachable in the subset automaton D(N ).\nThe proof is by induction on |S|. The basis, with |S| = 0, holds true since each\nstate (j, ) with j n1 1 is reached from the initial state (s1 , ) by aj 1\n1 . Let |S| 1.\nThere are three cases to consider.\nCase 1: j = f1 . Then s2 S since (f1 , S) is valid. Since a1 performs\na1\nthe circular shift in A1 , and the identity in A2 , we have (n1 1, S \\ {s2 }) \n(f1 , {s2 } (S \\ {s2 })) = (f1 , S), where the leftmost state is reachable by induction.", "State Complexity of Multiple Concatenation", "9", "Case 2: j = s1 . Let m = min S. Then s2 am 1\n(S), and |am 1\n(S)| = |S| since a2\n2\n2\nperforms a permutation on the state set of A2 . Since a1 performs the identity on the\nstate set of A2 , we have\nam 1", "a", "1\n2\n(f1 , am 1\n(s1 , am 1\n(S)) \n(S)) \n = (s1 , S),\n2\n2", "where the leftmost state is reachable as shown in Case 1.\naj 1", "Case 3: 2 j n1 1. Then we have (s1 , S) 1 (j, S), where the left state is\nconsidered in Case 2.\nThus, the two simple symbols a1 and a2 guarantee the reachability of all valid\nstates in the subset automaton D(N ). However, since both these symbols perform\npermutations on the state set Q2 of A2 , we have Q2 a1 = Q2 a2 = Q2 . It follows\nthat in D(N ), all states (i, Q2 ) are equivalent to the final sink state.\nTo guarantee distinguishability, we add one more input symbol b which performs\nthe contractions s1 2 and s2 2, and denote the resulting automata A 1 and A 2 ,\nrespectively. The NFA N recognizing L(A 1 )L(A 2 ) is shown in Figure 3.\na2 , b", "a2", "N", "s1 =1", "a1 , b", "2", "a2 , b\na1", "...", "a1", "n1 1", "a2 , b\na1", "f1 =n1", "a1\na2 , b", "a1\na1 , b", "a1", "s2 =1", "a2 , b", "a2", "2", "a1 , b", "a1 , b", "...", "a2", "n2 1", "a2", "f2 =n2", "a2 , b\nFigure 3: The NFA N recognizing the language L(A 1 )L(A 2 ).", "As shown above, all valid states (j, S) are reachable in the corresponding subset\nautomaton D(N ). To get distinguishability, let us show that each singleton set is\nco-reachable in N . In the reversed automaton (N )R , the initial set is {f2 }, and\na", "a", "a", "a", "a", "2\n2\n2\n2\n2\n{f2 } \n{n2 1} \n{n2 2}", "{2} \n{s2 }.", "Next, since n1 3, we have\nb", "a", "a", "a", "a", "1\n1\n1\n1\n{s2 } \n {f1 } \n{n1 1}", "{2} \n{s1 };", "10", "J. Jir sek, G. Jir skov \nb", "notice that we need n1 3 to get {s2 } \n {f1 }, in the case of n1 = 2 we would\nb", "have {s2 } \n {f1 , s1 }. Hence each singleton set is co-reachable in N . By Corollary 2,\nall states of the subset automaton D(N ) are pairwise distinguishable.", "We use the ideas from the above example to describe witnesses for multiple concatenation over a (k + 1)-letter alphabet. To this aim, let k 2 and ni 3\nfor i = 1, 2, . . . , k. Let Σ = {b, a1 , a2 , . . . , ak } be an alphabet consisting of k + 1\nsymbols. Define an ni -state DFA Ai = (Qi , Σ, , si , {fi }), where\n Qi = {1, 2, . . . , ni },\n si = 1,\n fi = ni ,\n ai : (1, 2, . . . , ni ), aj : (1) if j = i, b : (1 2),\nthat is, the symbol ai performs the circular shift on Qi , each symbol aj with j = i\nperforms the identity, and the symbol b performs a contraction. The DFA Ai is shown\nin Figure 4; here Σ \\ {ai } on a loop means that there is a loop in the corresponding\nstate on each symbol in Σ \\ {ai }, and the same for Σ \\ {ai , b}.\nΣ \\ {ai , b}", "Ai", "si =1", "Σ \\ {ai }\nai , b", "2", "Σ \\ {ai }", "Σ \\ {ai }\nai", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "Figure 4: The witness DFA Ai over the (k + 1)-letter alphabet {b, a1 , a2 , . . . , ak }.", "First, let us consider the concatenation L(Ai 1 )L(Ai ) where 2 i k. Construct\nan NFA Ni for this concatenation from DFAs Ai 1 and Ai as shown in Figure 5, that\nis, by adding the transitions (fi 1 1, ai 1 , si ) and (fi 1 , σ, si ) with σ Σ \\ {ai 1 },\nby making the state fi 1 non-final, and the state si non-initial. The next observation is crucial in what follows.", "It shows that in the subset automaton D(Ni ), each state (si 1 , S) with S Qi and S = is reachable from (si 1 , {si }). Moreover, while reaching (si 1 , S) with fi \n/ S, the state fi is never visited. This\nis a very important property since, later, we do not wish to influence the (i + 1)st\ncomponent of a valid state while setting its ith component.", "Lemma 11. Let 2 i k and Ni be the NFA for the language L(Ai 1 )L(Ai )\ndescribed above. For every non-empty subset S Qi , there exists a string wS over\nthe alphabet {ai 1 , ai } such that in the subset automaton D(Ni ), we have\nw", "S\n(i) (si 1 , {si }) \n(si 1 , S);", "u", "(ii) if fi \n/ S, u is a prefix of wS , and (si 1 , {si }) \n (q, T ), then fi \n/ T.", "State Complexity of Multiple Concatenation\nΣ \\ {ai 1 , b} Σ \\ {ai 1 }", "Ni", "si 1", "ai 1 , b", "Σ \\ {ai 1 }", "ai 1", "2", "11", "ai 1", "...", "ni 1 1", "Σ \\ {ai 1 }", "ai 1", "fi 1", "ai 1\nΣ \\ {ai }", "ai 1", "Σ \\ {ai , b}", "si", "Σ \\ {ai }", "ai , b", "ai", "2", "Σ \\ {ai }", "Σ \\ {ai }", "...", "ai", "ni 1", "ai", "fi", "ai , b\nFigure 5: The NFA Ni recognizing the language L(Ai 1 )L(A i).", "Proof. The proof of both (i) and (ii) is by induction on |S|. The basis, with |S| = 1,\nholds true since we have\na", "a", "a", "a", "i\ni\ni\ni\n(si 1 , {si }) \n(si 1 , {2})", "(si 1 , {ni 1}) \n(si 1 , {fi }),", "so, for each j Qi , the state (si 1 , {j}) is reached from (si 1 , {si }) by aj 1\n. Morei\nover, if j = fi , then fi is not visited while reading aj 1\n.\ni\nLet |S| 2. Let m = min S and S = am 1\n(S \\ {m}). Then |S | = |S| 1. By\ni\nreading ni 1 times the symbol ai 1 and then the string am 1\nwe get\ni\nn", "i 1\nai 1", "am 1", "i\n(si 1 , S ) (si 1 , {si } S ) \n (si 1 , {m} (S \\ {m})) = (si 1 , S),", "where the leftmost state is reached from (si 1 , {si }) by the string wS by induction,\nni 1 m 1\nso wS = wS ai 1\nai\n. Moreover, if fi \n/ S, then S [2, fi m], so fi \n/ S .", "By induction, the state fi has not been visited while reading wS to reach (si 1 , S )\nfrom (si 1 , {si }). Since in Ai , the symbols ai 1 and ai perform the identity\nand circular shift, respectively, the state fi is not visited either while reading the\nni 1 m 1\nstring ai 1\nai\nto reach (si 1 , S) from (si 1 , S ).", "Now, construct the NFA N recognizing the concatenation L(A1 )L(A2 ) L(Ak )\nfrom DFAs A1 , A2 , . . . , Ak as follows: First, for each i = 1, 2, . . . , k 1, add\nthe transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) with σ Σ \\ {ai }. Then, make\nstates f1 , f2 , . . . , fk 1 non-final, and states s2 , s3 , . . . , sk non-initial; see Figure 6 for\nan illustration.", "12", "J. Jir sek, G. Jir skov \na2 , a3", "N", "s1", "a2 , a3 , b\na1 , b", "2", "a2 , a3 , b\na1", "a1\na1\na1 , a3", "s2", "f1\na2 , a3 , b\na1 , a3 , b", "a2 , b", "2", "a1 , a3 , b\na2", "3", "a2", "a1 , a3 , b\na2", "a2\na1 , a2", "s3", "f2\na1 , a3 , b\na1 , a2 , b", "a1 , a2 , b\na3 , b", "2", "a3", "f3", "a3\nFigure 6: The NFA N for L(A1 )L(A2 )L(A3 ) with n1 = 3, n2 = 4, and n3 = 3.", "Theorem 12. Let k 2 and ni 3 for i = 1, 2 . .", ". , k. Let Ai be the ni -state DFA\nfrom Figure 4.", "Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all\nvalid states are reachable and pairwise distinguishable in the subset automaton D(N ). Proof.", "We first prove reachability. Let q = (j, S2 , S3 , . .", ". , Sk ) be a valid state. If S2 = , then the state q = (j, , , .", ". . , ) is reached from the initial\nstate (s1 , , , .", ". . , ) by the string aj 1\n1 .", "Next, let = max{i 2 | Si = }. Then q = (j, S2 , S3 , . .", ". , S , , , . .", ". , ) where 2 k, Si Qi and Si = \nfor i = 2, 3, . .", ". , . Since each ai performs the circular shift in Ai and the identity\nn 1\nin Aj with j = i, the string an1 1 a2n2 a 1\nsends the initial state (s1 , , , .", ". . , ) to\n(s1 , {s2 }, {s3 }, .", ". . , {s 1 }, {s }, , , .", ". . , ).", "Now, we are going to set the corresponding components to sets Si , starting with S ,\ncontinuing with S 1 , S 2 , . . .", ", and ending with S3 and S2 . By Lemma 11 applied to the NFA N recognizing the language L(A 1 )L(A ), there is a string wS \nover {a 1 , a } which sends (s 1 , {s }) to (s 1 , S ) in the subset automaton D(N ). Moreover, since q is valid, we have f \n/ S , which means that the state f is not visited\nwhile reading wS .", "Since both a 1 and a perform identities on Q1 , Q2 , . . .", ", Q 2 , in\nthe subset automation D(N ) we have\nwS", "(s1 , {s2 }, . . . , {s 1 }, {s }, , . . . , ) \n(s1 , {s2 }, . . . , {s 1 }, S , , . . . , ).", "State Complexity of Multiple Concatenation", "13", "Next, Lemma 11 applied to N 1 gives a string wS 1 over {a 2 , a 1 } which\nsends (s 2 , {s 1 }) to (s 2 , S 1 ) in D(N 1 ), and moreover if f 1 \n/ S 1 ,\nthen f 1 is not visited while reading this string. Since both symbols a 2 and a 1\nperform identities on Q1 , Q2 , . . . , Q 3 , as well as on Q , in D(N ) we have\nwS 1", "(s1 , {s2 }, . . . , {s 2 }, {s 1 }, S , , . . . , ) (s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ).\nNow, for i = 2, 3, . . . , 2, let wSi be the string over {ai 1 , ai } given by Lemma 11\nthat sends (si 1 , {si }) to (si 1 , Si ) in the NFA Ni for L(Ai 1 )L(Ai ). Moreover,\nfi \n/ Si implies that the state fi is never visited while reading wSi , which in turn\nimplies that si+1 is never added to the (i + 1)th component in such a case. If fi Si\nand i k 1, then the state si+1 is included in Si+1 since the state q is valid, and si+1\nis sent to itself by both ai 1 and ai . Next, there is a loop on both symbols ai 1 and ai\nin the states s1 , s2 , . . . , si 2 , as well as in all states of automata Ai+1 , Ai+2 , . . . , A .\nSet W = wS 2 wS 3 wS3 wS2 . Then in D(N ) we have\nW", "(s1 , {s2 }, . . . , {s 2 }, S 1 , S , , . . . , ) (s1 , S2 , . . . , S 2 , S 1 , S , , . . . , ),\nand the resulting state is sent to the state q by the string aj 1\n1 . Hence the valid\nstate q = (j, S2 , S3 , . . . , S , , , . . . , ) is reached from the initial state (s1 , , , . . . , )\nn 1\nby the string an1 1 an2 2 a 1\nwS wS 1 wS3 wS2 aj 1\n1 .\nTo get distinguishability, let us show that each singleton set is co-reachable in N .\nFirst, for an example, consider the NFA from Figure 6. In its reversed automaton,\nthe initial set is {f3 }, and we have\na", "a", "b", "a", "a", "a", "b", "a", "a", "3\n3\n2\n2\n2\n1\n1\n{f3 } \n{2} \n{s3 } \n {f2 } \n{3} \n{2} \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of N R is {fk }. Next, for each i = 1, 2, . .", ". , k, each\nsingleton set {j} such that j Qi is reached from {fi } via a string in a i . Finally, for\neach i = 2, 3, .", ". . , k, the singleton set {fi 1 } is reached from {si } by b since ni 1 3.", "Thus, for every state q of N , the singleton set {q} is co-reachable in the NFA N . By\nCorollary 2, all states of the subset automaton D(N ) are pairwise distinguishable. Notice that all automata in the previous theorem, as well as witness automata\nfrom [1], are required to have at least three states.", "We conclude this section by\ndescribing the witnesses for multiple concatenation also in the case where some of\ngiven automata have two states. The idea is to use symbols ak and b to guarantee\nco-reachability of singleton sets in such a way that they perform either the identity\nor (1 2 ni ) in every second automaton. However, then we should\nbe careful with reachability.", "To this aim, let k 2, ni 2 for i = 1, 2, . . .", ", k,\nand Σ = {b, a1 , a2 , . . .", ", ak }. Let\nI = {i | 1 i k 1 and i mod 2 = k mod 2}\nJ = {i | 1 i k 1 and i mod 2 = k mod 2},", "14", "J. Jir sek, G. Jir skov", "that is, the set I contains the indexes that have the same parity as k, and the set J\nthe others.\nConsider the ni -state DFAs Ai = (Qi , Σ, , si , {fi }), see Figure 7, where we\nhave Qi = {1, 2, . . . , ni }, si = 1, fi = ni , and the transitions are as follows:\nif i I, then ai : (1, 2, . . . , ni ), ak : (1 2 ni ), and σ : (1) if σ Σ\\{ai , ak },\nif i J, then ai : (1, 2, . . . , ni ), b : (1 2 ni ), and σ : (1) if σ Σ \\ {ai , b},\nif i = k, then b : (1, 2, . . . , nk ), ak : (1 2 nk ), and σ : (1) if σ Σ \\ {ak , b},\nthat is,\nΣ \\ {ai , ak }", "Ai (i I)", "si =1", "Σ \\ {ai , ak }", "ai , ak", "2", "ai , ak", "Σ \\ {ai , ak }", "...", "ai , ak", "ni 2", "Σ \\ {ai , ak }", "ai , ak", "fi =ni", "ak", "ai\nΣ \\ {ai , b}", "Ai (i J)", "si =1", "Σ \\ {ai , b}\nai , b", "2", "Σ \\ {ai , b}", "Σ \\ {ai , b}\nai , b", "...", "ai , b", "ni 2", "ai , b", "fi =ni", "b", "ai\nΣ \\ {ak , b}", "Ak", "sk =1", "Σ \\ {ak , b}", "ak , b", "2", "ak , b", "Σ \\ {ak , b}", "...", "ak , b", "nk 2", "Σ \\ {ak , b}", "ak , b", "fk =nk", "ak", "b\nFigure 7: The DFAs Ai with i I (top), Ai with i J (middle), and Ak (bottom).", "each ai with 1 i k 1 performs the circular shift on Qi , and the identity\non Qj with j = i;\n ak performs the transformation (1 2 3 ni ) on Qi with i I\nor i = k, and the identity on Qi with i J,\n b performs the transformation (1 2 3 ni ) on Qi with i J, the\ncircular shift on Qk , and the identity on Qi with i I.", "State Complexity of Multiple Concatenation", "15", "Construct an NFA N for the language L(A1 )L(A2 ) L(Ak ) from the\nDFAs A1 , A2 , . . .", ", Ak as follows (see Figure 8 for an illustration):\nFor each i = 1, 2, . . .", ", k 1, add the transitions (fi 1, ai , si+1 ) and (fi , σ, si+1 ) for\neach σ Σ \\ {ai }, and moreover, if i I, then add the transition (fi 1, ak , si+1 ),\nand if i J, then add the transition (fi 1, b, si+1 ). The initial state of N is s1 , and\nits unique final state is fk . Theorem 13.", "Let k 2 and ni 2 for i = 1, 2, . . .", ", k. Let A1 , A2 , . .", ". , Ak be\nthe DFAs shown in Figure 7, and N be the NFA for L(A1 )L(A2 ) L(Ak ) described\nabove. Then all valid states are reachable and pairwise distinguishable in D(N ).", "Proof. First, notice that Lemma 11 still holds for automata A1 , A2 , . .", ". , Ak 1 since\nthe transitions on a1 , a2 , . .", ". , ak 1 are the same. Thus, for each non-empty subset S\nof Qi with i k 1, let wS be the string over {ai 1 , ai } given By Lemma 11.", "Let ({j}, S2 , S3 , . . .", ", Sk ) be a valid state. If Sk = , then (j, S2 , S3 , . .", ". , Sk 1 , ) is\nreachable as shown in the proof of Theorem 12. Now, let Sk = .", "Then the state (s1 , {s2 }, {s3 }, . . .", ", {sk }) is reached from the initial\nnk 1\nstate by an1 1 an2 2 ak 1\n. Next, notice that Lemma 11 still holds for Nk even if ak\nfixes fk instead of sending it to sk since the out-transition in fk on ak is not used in\nthe proof of the lemma. Hence, there is a string w(Sk ) over {ak 1 , ak } which sends\nthe state (sk 1 , {sk }) to (sk 1 , Sk ) in the subset automaton D(Nk ).", "However, each ak\nsends each state si with i I to si +1, and we must then read the string ui = (ai )ni 1\nto send sQ\ni + 1 back to si while fixing the states in all the remaining components. Let u = i I ui . Now, let w (Sk ) be the string obtained from w(Sk ) by inserting u\nafter each ak .", "Since before reading each ak in wSk we have sk 1 in the (k 1)st\ncomponent, the state (s1 , {s2 }, . . .", ", {sk 1 }, {sk }) is sent to (s1 , {s2 }, . . .", ", {sk 1 }, Sk )\nby wS k , and then to (j, S2 , S3 , . . .", ", Sk 1 , Sk ) by wSk 1 wSk 2 wS3 wS2 aj 1\n1 . To prove distinguishability, let us show that all singleton sets are co-reachable in\nthe NFA N . First, as an example, consider the NFA N from Figure 8, and notice\nthat in the reversed automaton N R , we have\nb", "a", "a", "b", "a", "a", "a", "a", "b", "a", "a", "5\n4\n3\n3\n{f5 } \n {s5 } \n{f4 } \n{s4 } \n {f3 } \n{2} \n{s3 }\n5\n2\n1\n1", "{f2 } \n{s2 } \n {f1 } \n{2} \n{s1 }.", "In the general case, the initial set of the reversed automaton N R is {fk }, and each\nset {q} with q Qk is reached from {fk } by a string in b . Next each {fi } with i J\nis reached from {si+1 } by ak , while each {fi } with i I is reached from {si+1 } by b.\nFinally, each {q} with q Qi , where 1 i k 1, is reached from {fi } by a string\nin a i . It follows that all singleton sets are co-reachable in N . By Corollary 2, all\nstates of D(N ) are pairwise distinguishable.", "5. Matching Lower Bound: k-letter Alphabet\nThe aim of this section is to describe witnesses for multiple concatenation over a kletter alphabet. Let us start with the following example.", "16", "J. Jir sek, G. Jir skov \na2 , a3 , a4 , b", "b", "A1", "s1", "a5", "2", "f1", "N", "a2 , a3 , a4 , b\na1 , a5", "s1", "a1 , a3 , a4 , a5", "s2", "a1 , a3 , a4 , a5 , b", "a2 , b\na1 , a2 , a4 , b", "s3", "2", "f3", "a1 , a2 , a4 , b\na3 , a5", "s3", "a1 , a2 , a3 , a5", "s4", "f4", "s4", "a4 , b", "s5", "f3", "a1 , a2 , a4 , a5 , b", "f4", "a1 , a2 , a3 , a4 , a5", "a1 , a2 , a3 , a4", "f5", "a3 , a5", "a1 , a2 , a3 , a5 , b", "a4 , b", "s5", "a1 , a2 , a4 , a5 , b", "a1 , a2 , a3 , a5 , b", "a4", "A5", "2\na3", "a3 , a5", "A4", "a2 , a3 , a4 , a5 , b", "f2", "a2", "A3", "f1", "a1 , a3 , a4 , a5 , b\na2 , b", "s2", "f2", "a1 , a5", "a1", "a1 , a5", "A2", "2", "a2 , a3 , a4 , a5 , b", "a5 , b", "f5", "b\nFigure 8: The DFAs A1 , A2 , A3 , A4 , A5 : transitions on a5 and b (left) and the NFA N\nfor L(A1 )L(A2 )L(A3 )L(A4 )L(A5 ) (right) with n1 = n3 = 3 and n2 = n4 = n5 = 2.", "State Complexity of Multiple Concatenation", "17", "Example 14. Let n1 , n2 1 and A and B be the binary DFAs shown in Figure 9.\nLet us show that the languages L(A) and L(B) are witnesses for concatenation of two\nregular languages.\nb", "b", "b", "b\nb\nA", "s1 =1", "a", "a", "2", "3", "...", "a", "n1 1", "a", "f1 =n1", "a", "b", "B", "a", "s2 =1", "a", "a, b", "2", "3", "a, b", "...", "a, b", "n2 1", "a, b", "f2 =n2", "a, b\nFigure 9: The binary witnesses for concatenation; n1 , n2 1.", "First, let n2 = 1. Then L(B) = {a, b} and the concatenation L(A){a, b} is\nrecognized by the minimal n1 -state DFA obtained from A by replacing the transition (f1 , a, s1 ) with the transition (f1 , a, f1 ). An upper bound is n1 by Proposition 8.\nNow, let n1 = 1 and n2 2. Then s1 = f1 . Construct an NFA N for L(A)L(B)\nfrom the DFAs A and B by adding the transitions (f1 , a, s2 ) and (f1 , b, s2 ), and by\nmaking the state s1 non-final. Let us show that all valid states (f1 , S) are reachable in D(N ). Since (f1 , S) is valid, we have s2 S. The proof is by induction\non |S|. The basis, |S| = 1, that is, S = {s2 }, holds true since (f1 , {s2 }) is the initial state. Let |S| 2 and s2 S. Let m = min(S \\ {s2 }) and S = S \\ {s2 , m}.\nThen abm 2 (S ) [2, n2 m + 1] and\na", "bm 2", "(f1 , {s2 } abm 2 (S )) \n (f1 , {s2 , 2} bm 2 (S )) (f1 , {s2 , m} S ) = (f1 , S),\nwhere the leftmost valid state is reachable by induction. This proves the reachability\nof 2n2 1 valid states. All these states are pairwise distinguishable by Lemma 1 since\nall singletons {q}, where q is a state of B, are co-reachable in N .", "By Proposition 8,\nan upper bound is V2 = 2n2 1 . Finally, let n1 , n2 2. Construct an NFA N for L(A)L(B) from the DFAs A and B\nby adding the transitions (f1 1, a, s2 ) and (f1 , b, s2 ), by making the state f1 nonfinal and the state s2 non-initial.", "Let us show that in the subset automaton D(N ),\neach valid state (j, S) is reachable. The proof is by induction on |S|. The basis,\nwith |S| = 0, holds true since each valid state (j, ) is reached from the initial state\nis (s1 , ) by aj 1 .", "Let |S| 1. There are three cases to consider.", "18", "J. Jir sek, G. Jir skov", "Case 1: j = f1 . Then s2 S since (f1 , S) is valid. We have\na", "(f1 1, a(S \\ {s2 })) \n (f1 , {s2 }) (S \\ {s2 }) = (f1 , S)\nwhere the leftmost valid state is reachable by induction.\nCase 2: j = s1 .\nCase 2.a: 2 S. Then s2 a(S) and (s1 , S) is reached from (f1 , a(S)) by a, where\nthe latter valid state is considered in Case 1.\na", "bn2", "Case 2. b: 2 \n/ S and S = {s2 }. Then we have (f1 , {s2 }) \n (s1 , {2}) (s1 , {s2 }),\nwhere the leftmost state is considered in Case 1.", "Case 2. c: 2 \n/ S and S = {s2 }. Let m = min(S \\ {s2 }) and S = S {s2 }.", "m 2\nThen 2 b\n(S \\ {s2 }) and (s1 , S) is reached from (s1 , S bm 2 (S \\ {s2 })) by bm 2\nwhere the latter state is considered in Case 2. a. Case 3: 2 j n1 1.", "Then (j, S) is reached from (s1 , aj 1 (S)) by aj 1 , and the\nlatter set is considered in Case 2. This proves the reachability of (n1 1)2n2 + 2n2 1 states. To get distinguishability,\nlet (i, S) and (j, T ) be two distinct valid states.", "There are two cases to consider. Case 1: S = T . The the two states are distinguishable by Lemma 1 since all singletons {q}, where q is a state of B, are co-reachable in N .", "Case 2: S = T and i < j. First, let S = . Since n1 2, the string an1 j sends the\ntwo states to states that differ in s2 .", "The resulting states are distinguishable as shown\nin Case 1. Now, let S = . Then the two states are sent to (s1 , {s2 }) and (f1 , {s2 })\nby an1 j bn2 .", "Let us show that the resulting states are sent to states that differ in s2\nby an1 if s2 an1 = s2 , and by an1 1 ban1 1 otherwise. First, notice that both strings an1 and an1 1 ban1 1 send the state f1 to itself in A. It follows that (f1 , {s2 }) is sent to a state containing s2 in its second component by\nboth these strings.", "Now, let s2 an1 = s2 . Then we have\nan1 1", "a", "(s1 , {s2 }) (f1 , {s2 , s2 an1 1 }) \n (s1 , {s2 a, s2 an1 }),\nwhere s2 a = s2 since n2 2. Thus, in this case, the string an1 sends the\nstate (s1 , {s2 }) to a state which does not have s2 in its second component.\nFinally, let s2 an1 = s2 . Then s2 an1 1 = f2 and since s2 b = f2 b = s2 , we have\nan1 1", "b", "an1 1", "(s1 , {s2 }) (f1 , {s2 , f2 }) \n (f1 , {s2 }) (f1 1, {f2 }),\nwhere f2 = s2 since n2 2. Hence, this time the string an1 1 ban1 1 sends (s1 , {s2 })\nto a state which does not contain s2 in its second component.\nThis proves distinguishability, and concludes our proof since by Theorem 6, a\n(known) upper bound is (n1 1)U2 + V2 = (n1 1)2n2 + 2n2 1 in this case.", "State Complexity of Multiple Concatenation", "19", "Hence the above example provides a two-letter witnesses for the concatenation of\ntwo regular languages (even in the case then automata may have one or two states). Therefore, in what follows we assume that k 3. We use our previous results to describe witnesses for the concatenation of k\nlanguages over the k-letter alphabet {b, a1 , a2 , .", ". . , ak 1 }.", "The idea is as follows. The transitions on input symbols a1 , a2 , . .", ". , ak 1 in automata A1 , A2 , . .", ". , Ak 1 are\nthe same as in our (k + 1)-letter witnesses from Theorem 12, while Ak 1 and Ak\nover {ak 1 , b} are the same as automata A and B in Example 14. The input symbol b\nperforms the transformation ({2, 3, .", ". . , ni 1} si ) in each Ai except for Ak , and\nit is used to get reachability as well as distinguishability.", "To this aim, let k 3 and Σ = {b, a1 , a2 , . . .", ", ak 1 } be a k-letter alphabet. Let n1 , nk 2 and ni 3 for i = 2, 3, . .", ". , k 1. For i = 1, 2, .", ". . , k, define an ni -state\nDFA Ai = (Qi , Σ, , si , {fi }), see Figure 10, where Qi = {1, 2, .", ". . , ni }, si = 1, fi = ni ,\nand the transitions are as follows:\n if i k 1, then\nai : (1, 2, .", ". . , ni ), b : ({2, 3, .", ". . , ni 1} si ), and σ : (1) if σ Σ \\ {ai , b},\n if i = k, then\nak 1 : (1, 2, .", ". . , nk ), b : (2 3 nk 1), and σ : (1) if σ Σ \\ {ak 1 , b}.", "b\nb", "b", "b\nb", "Ai\n(i<k)", "si =1", "ai", "2", "ai", "3", "sk =1", "...", "ai", "ni 1", "ai", "fi =ni", "ai", "b", "Ak", "ai", "ak 1", "2", "ak 1 , b", "3", "ak 1 , b", "...", "ak 1 , b", "nk 1", "ak 1 , b", "fk =nk", "ak 1 , b\nFigure 10: The DFA Ai with i < k (top): transitions on ai and b, and the DFA Ak\n(bottom): transitions on ak 1 and b; all the remaining symbols in both automata\nperform identities; n1 , nk 2 and ni 3 for i = 2, 3, . . . , k 1.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from DFAs A1 , A2 , . . . , Ak by\nadding the transitions (fi 1, ai , si+1 ), (fi , aj , si+1 ) for j = i, and (fi , b, si+1 )\nfor i = 1, 2, . . . , k 1; the initial state of N is s1 , and the final state is fk . The\nnext theorem shows that all valid states are reachable and pairwise distinguishable\nin D(N ). The proof of reachability is based on our results concerning (k + 1)-letter\nwitnesses as well as our binary witnesses from Example 14. The proof of distinguishability is not for free this time.", "20", "J. Jir sek, G. Jir skov", "Theorem 15. Let k 3, n1 , nk 2, and ni 3 for i = 2, 3, . .", ". , k 1. Let A1 , A2 , .", ". . , Ak be DFAs shown in Figure 10 over the k-letter alphabet {b, a1 , a2 , .", ". . , ak 1 }.", "Let N be the NFA for L(A1 )L(A2 ) L(Ak ) described above. Then all valid states are reachable and pairwise distinguishable in D(N ). Proof.", "Consider a valid state q = (j, S2 , . . .", ", Sk 1 , Sk ). First, let Sk = . Since the\ntransitions on a1 , a2 , .", ". . , ak 1 in A1 , A2 , .", ". . , Ak 1 are the same as in automata in\nTheorem 12, the valid state (j, S2 , .", ". . , Sk 1 , ) is reachable exactly the same way as\nin the proof of this theorem.", "Now let Sk = . Notice that the transitions on ak 1 and b in DFAs Ak 1 and Ak\nare the same as those on a and b in DFAs A and B in Example 14. As shown in this\nexample, for each S Qk , there is a string wS over {ak 1 , b} which sends (sk 1 , )\nto (sk 1 , S) in the subset automaton for L(Ak 1 )L(Ak ).", "Since we have a loop on both\nak 1 and b in all states s1 , s2 , . . .", ", sk 2 , we reach (s1 , {s2 }, {s3 }, . . .", ", {sk 2 }, {sk 1 }, S)\nnk 2\nfrom the initial state by an1 1 an2 2 ak 2\nwS . Next, let wSi be the string\nover {ai 2 , ai 1 } given by Lemma 11 which sends (si 1 , {si }) to (si 1 , Si ). Recall that fi \n/ Si implies that the state fi is not visited while reading wSi .", "Moreover, a closer look at the proof of the lemma shows that if fi Si then fi is visited for the first time immediately after reading the last ai in wSi . Now, let m\nbe the number of occurrences of the symbol ak 1 in the string wSk 1 . Then the\nstate (s1 , {s2 }, {s3 }, .", ". . , {sk 2 }, {sk 1 }, am\nk 1 (Sk )) is reachable as shown above, and\nit is sent to (s1 , {s2 }, {s3 }, .", ". . , {sk 2 }, Sk 1 , Sk ) by wSk 1 .", "The resulting state is sent\nto q by the string wSk 2 wSk 3 wS3 wS2 aj 1\n1 . To get distinguishability, let p = (S1 , S2 , S3 , . .", ". , Sk ) and q = (T1 , T2 , T3 , . .", ". , Tk )\nbe two distinct valid states. If Sk = Tk , then p and q are distinguishable by Lemma 1\nsince each singleton subset of Qk is co-reachable in N via a string in a k 1 .", "Let Si = Ti for some i with 1 i k 1, and Sj = Tj for j = i + 1, i + 2, . . .", ", k. Let us show that there is a string that sends p and q to two states which differ in si+1 . Without loss of generality, we have s Si \\ Ti .", "First, we read the string w = afi i s\nwhich sends s to fi in Ai and fixes all states in all Aj with j = i to get states", "(S1 , S2 , S3 , . . . , Si 1\n, S (Si w), Si+1\n, . . . , Sk )", "(T1 , T2 , T3 , . . . , Ti 1\n, T (Ti w), Ti+1\n, . . . , Tk )", "where S , T [1, fi s] and fi (Si w) \\ (Ti w), that is, the ith components of", "the resulting states differ in the state fi . If Si+1\n = Ti+1\n, then we have the desired", "result. Otherwise, since si+1 Si+1 , both Si+1 and Ti+1 are non-empty, which means\nthat all S1 , S2 , . . . , Si and all T1 , T2 , . . . , Ti are non-empty. Now, the string b sends\nall states of Qj with 2 j k 1, either to sj or to fj , and then aj b sends fj to sj\nand sj to itself since nj 3. Thus after reading the string b(a2 b)(a3 b) (ai 1 b) and\nif T1 = {f1 }, then also (a1 b), we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, Si+1\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", Ti+1\n, . . . , Tk )", "where q {s1 , f1 }, S {si }, and Sj , Tj {sj , fj } for j = i + 1, i + 2, . . . , k 1.\nThere are two cases to consider.", "State Complexity of Multiple Concatenation", "21", "Case 1: 1 i k 2. Then 2 i + 1 k 1 and ni+1 3 which means that the\nstring ai+1 b sends both fi+1 and si+1 to si+1 . Thus after reading ai+1 b, we get states", "( {q}, {s2 }, {s3 }, . . . , {si 1 }, S {fi }, {si+1 }, Si+2\n, . . . , Sk )", "({s1 }, {s2 }, {s3 }, . . . , {si 1 },", "{si }", ", {si+1 }, Ti+2\n, . . . , Tk ).", "Finally, the string ai+1 , which performs the identity on Qj with j = i + 1 and the\ncircular shift on Qi+1 , sends the resulting states to states which differ in si+1 .\nCase 2: i = k 1. Then the string bnk sends all states of Qk to sk , while it fixes sj\nand fj for j = 1, 2, . . . , k 1. Thus after reading the string bnk we get states\n({q}, {s2 }, . . . , {sk 2 }, S {fk 1 }, {sk }) and ({s1 }, {s2 }, . . . , {sk 2 }, {sk 1 }, {sk }).\nk\nNow, in the same way as in Example 14 we show that either the string ank 1\nor the\nnk 1 nk 1\nstring ak 1 bak 1 sends the resulting states to two states which differ in sk .", "Since the number of valid states provides an upper bound on the state complexity\nof multiple concatenation, we get our main result.\nCorollary 16. The DFAs A1 , A2 , . . . , Ak shown in Figure 10 defined over a k-letter\nalphabet are witnesses for multiple concatenation of k languages.", "We conjecture that k symbols are necessary for describing witnesses for concatenation of k languages. The next observation shows that our conjecture holds for k = 3. Theorem 17.", "The ternary alphabet used to describe witnesses for the concatenation\nof three languages in Theorem 15 is optimal. Proof. Let Σ = {a, b} and ni 2 for i = 1, 2, 3.", "Let us consider binary DFAs\nAi = (Qi , Σ, , si , {fi }) where Qi = {1, 2, . . .", ", ni }, si = 1, fi = 1 for i = 1, 2, 3; notice\nthat to meet the upper bound for multiple concatenation, each A1 , A2 , . . .", ", Ak 1 must\nhave one final state, and it must be different from the initial state. Construct the NFA N for L(A1 )L(A2 )L(A3 ) from DFAs A1 , A2 , A3 as follows:\nfor i = 1, 2, each state q Qi and each symbol σ {a, b} such that qσ = fi ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its unique final state\nis f3 . Our aim is to show that either some valid state is unreachable in the subset\nautomaton D(N ) or some valid states are equivalent to each other.", "Notice that to reach the valid state (s1 , Q2 , {s3 }), we must have an input symbol\nthat performs a permutation on Q2 , and to reach the valid state (s1 , {s2 }, Q3 ), we\nmust have an input symbol that performs a permutation on Q3 . If both input symbols perform a permutation on Q3 , then the valid states (s1 , {s2 }, Q3 ) and (s1 , {2}, Q3 ) are equivalent since all strings are accepted from\nboth of them. If both input symbols perform a permutation on Q2 , then the valid states (s1 , Q2 , {s3 }) and (2, Q2 , {s3 }) are equivalent since if a string w is accepted by N\nw", "w", "from the state s1 in A1 through a computation s1 s2 f3 with w = w w ,\nw", "w", "then it is accepted through a computation w s2 s2 f3 where w s2 Q2 , so it\nis accepted from (2, Q2 , {s3 }); and vice versa.", "22", "J. Jir sek, G. Jir skov", "Hence to meet the upper bound, we must have one permutation and one nonpermutation input symbol in both A2 , A3 . Next, while reaching the valid state (s1 , Q2 \\{f2 }, ), we cannot visit state f2 . This\nmeans that there must be an input that maps Q2 \\ {f2 } onto Q2 \\ {f2 }.", "Without loss\nof generality, let this input be a. Since f2 must be reachable in A2 , there must exist\na state p in Q2 \\ {f2 } with pb = f2 . Moreover, f2 b = f2 because otherwise either f2\nwould have loops on both symbols, or both a and b would be non-permutation symbols\nin A2 .", "We have two cases:\n(1) Let b be a non-permutation symbol in A2 . Then a is a permutation on Q2 ,\nso f2 a = f2 . This situation is depicted in Fig.", "11. Moreover, there is a state in Q2 \\{f2 }\nwith no in-transition on b. Therefore the valid state (s1 , Q2 \\ {f2 }, Q3 ) must be\nreached from some valid state on a, and consequently a is a permutation on Q3 .", "Next, since f2 b = f2 , the valid state (s1 , {f2 b}, Q3 ) must be reached from a valid\nstate (j, {f2 } S, Q3 ) on b since to get Q3 in the third component, we must visit f2 ,\nand only reading b eliminates the state f2 . It follows that b is a permutation on Q3 . Hence both a and b perform permutations on Q3 , thus resulting in a contradiction.", "b\nA2", "0", "p", "a", "q\nb", "f2", "Figure 11: Case 1: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is not a permutation on Q2 .", "(2) Let b be a permutation symbol in A2 . Then a is not a permutation on Q2 ,\nso f2 a = f2 , and therefore f2 \n/ Q2 a, so each state containing f2 in its second component must be reached by b. This situation is illustrated in Fig.", "12. It follows that\nevery valid state (j, Q2 , {s3 }) must be reached on b, so b is a permutation on Q1 ,\nNext, the valid state (s1 , {f2 }, Q3 ) must be reached on b as well. Therefore each\nstate in Q3 \\{s3 } has an in-transition on b.", "Moreover, the state (f1 b, Q2 , {s3 }) must be\nreached by b from a valid state (f1 , Q2 , {s3 } T ); recall that b is a permutation on Q1 . This means that s3 b = s3 . Hence b is a permutation on Q3 .", "Let r Q2 \\ {s2 b, f2 }. Then the valid state (f1 b, {r}, Q3 ) cannot be reached on b because otherwise it would\nbe reached from (f1 , {s2 } S, T ) and would contain s2 b in its second component. It\nfollows that a is a permutation on Q3 .", "Thus both a and b perform a permutation\nin A2 , which is a contradiction.", "Notice that all our k-letter witness DFAs from Theorem 15, except for the first\nand last one, are assumed to have at least three states. However, our witnesses over\na (k + 1)-letter alphabet from Theorem 13 cover also the cases when some of given\nDFAs have two states. Although, we are not able to cover such cases by using just k\nletters, we can do it providing that all automata have two states. We only give the\nmain ideas here for this case.\nLet Σ = {b, c, a2 , a3 , . . . ak 1 } be a k-letter alphabet. For i = 1, 2, . . . , k,\nlet Ai = (Qi , Σ, si , , fi ) be a two-state DFA with Qi = {1, 2}, si = 1, fi = 2,", "State Complexity of Multiple Concatenation", "23\nb", "A2", "p", "0", "q", "a", "b", "f2", "Figure 12: Case 2: a maps Q2 \\ {f2 } onto Q2 \\ {f2 } and b is a permutation on Q2 .", "and the transitions defined as follows (see Figure 13 for an illustration):\n ai with i = 2, 3, . . . , k 2 performs the cycle on Qi and the identity on Qj\nwith j = i;\n ak 1 performs the cycle on Qk 1 and Qk , and the identity on Q1 , Q2 , . . . , Qk 2 ;\n b performs the cycle on Q1 , the identity on Qi if i is even, and the contraction (fi si ) on Qi if i 3 is odd;\n c performs the identity on Qi if i is odd, and the contraction (fi si ) otherwise.\nc", "c", "a2", "b\nA1", "s1", "f1", "A2", "s2", "c", "s3", "b\na3", "a4\nf3", "A4", "c", "c", "s4", "s5", "b\na5", "c\na4", "f4", "b", "b", "a5\nA5", "f2", "b", "b", "a3\nA3", "c\na2", "b\nc", "b", "b", "a5\nf5", "A6", "s6", "c\na5", "f6", "Figure 13: Two-state DFAs; k = 6. In each DFA, the remaining symbols perform identities.", "Construct an NFA N for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . . . , Ak as\nfollows: for each i = 1, 2, . . . , k 1, each q Qi and σ Σ such that q σ = fi in Ai ,\nadd the transition (q, σ, si+1 ); the initial state of N is s1 and its final state is fk .\nWe prove reachability and distinguishability of states of the subset automaton D(N ) in a similar way as before, but we have take into account that to reach\na state p = (f1 , T2 , T3 , . . . , Tk ) from a state q = (s1 , S2 , S3 , . . . , Sk ), the symbol b has", "24", "J. Jir sek, G. Jir skov", "to be read. However, although b sends s1 to f1 , it also sends each non-empty subset Si\nwith i 3 and i odd to {si }. Then, we have to carefully return {si } back to Si .", "6. Binary and Ternary Languages\nIn this section, we examine the state complexity of multiple concatenation on binary\nand ternary languages. Our aim is to show that in the binary case, the resulting\ncomplexity is still exponential in n2 , n3 , .", ". . , nk , and in the ternary case, it is the same\nas in the general case, up to a multiplicative constant depending on k.", "Let us start\nwith the following example. Example 18. Let n 3 and N be the NFA shown in Figure 14 that recognizes the\nlanguage of strings over {a, b} which have an a in the (n 1)st position from the end.", "Let us show that each subset S [1, n] with 1 S is reachable in the subset\nautomaton D(N ). The proof is by induction on |S|. The basis, with |S| = 1, holds\ntrue since {1} is the initial state.", "Let |S| 2 and 1 S. Let m = min(S \\ {1}). Set S = abm 2 (S \\ {1, m}).", "Then S [2, n m + 1] and |S | = |S| 2. We have\nbs 2", "a", "{1} S \n {1, 2} bs 2 (S \\ {1, s}) {1, s} (S \\ {1, s}) = S, where the leftmost\nset of size |S| 1 is reachable by induction.", "We now use the result from the above example to get a lower bound on the state\ncomplexity of multiple concatenation on binary languages. The idea is to describe\nbinary DFAs in such a way that the NFA for their concatenation would accept, except\nfor a finite set, the set of strings having an a in an appropriate position from the end. Theorem 19.", "Let k 3, n1 3, n2 4, and ni 3 for i = 3, 4, . . .", ", k. Let A1 , A2 , . .", ". , Ak be the binary DFAs shown in Figure 15. Then every DFA for the\nlanguage L(A1 )L(A2 ) L(Ak ) has at least n1 1 + (1/22k 2 ) 2n2 +n3 + +nk states.", "Proof. Construct an NFA for L(A1 )L(A2 ) L(Ak ) from the DFAs A1 , A2 , . .", ". , Ak\nby adding the transitions (f1 1, b, s2 ), (f1 , a, s2 ), (f1 , b, s2 ), and (fi 1, σ, si+1 )\nfor i = 2, 3, . .", ". , k 1 and σ {a, b}, by making states f1 , f2 , . .", ". , fk 1 non-final, and\nstates s2 , s3 , . .", ". , sk non-initial. In this NFA, the states fi and fi +1 with 2 i k 1,\nas well as the state fk +1 are dead, so we can omit them.", "Let N be the resulting NFA;\nsee Figure 16 for an illustration. In the subset automaton D(N ), each state (j, , , . .", ". , ) with 1 j f1 1\nis reached from the initial state (s1 , , , . .", ". , ) by bj 1 , and (f1 , {s2 }, , , . .", ". , ) is\nreached from (f1 1, , , . .", ". , ) by b. Starting with the state f1 , the NFA N accepts\na, b", "N", "1", "a", "2", "a, b", "3", "a, b", "...", "a, b", "n 1", "a, b", "n", "Figure 14: A binary NFA N such that every set {1} S is reachable in D(N ).", "State Complexity of Multiple Concatenation", "25", "a, b", "a", "A1", "s1 =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "n1 2", "a, b", "n1 1", "b", "f1 =n1\na, b", "b", "A2", "a", "s2 =1", "a, b", "2", "3", "a, b", "...", "a, b", "n2 2", "a, b", "n2 1", "a, b", "f2 =n2\na, b", "Ai\n(i>2)", "si =1", "a, b", "a, b", "2", "3", "a, b", "...", "a, b", "ni 2", "a, b", "ni 1", "a, b", "fi =ni", "Figure 15: Binary DFAs A1 , A2 , and Ai for i = 3, 4, . . . , k meeting the lower bound\nn1 1 + (1/22k 1 )2n2 +n3 + +nk for multiple concatenation.", "a, b\na\nN", "s1 =1", "a, b", "a, b", "b", "b", "s2 =1", "2", "a", "3", "b", "f1 =4\na, b", "a, b\n2", "a, b", "3", "a, b", "4", "a, b", "a, b", "2", "a, b", "3", "a, b", "f3 =4", "a, b", "a, b", "2", "a, b", "6", "5\na, b", "a, b\ns4 =1", "a, b", "a, b", "a, b\ns3 =1", "f2 =5", "3", "a, b", "f4 =4", "a, b", "5", "Figure 16: A binary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "26", "J. Jir sek, G. Jir skov", "all strings having an a in position n2 2+n3 2+ +nk 1 2+nk 1 from the end. As\nshown in Example 18, every state (f1 {s2 } S2 , S3 , . . . , Sk ) with S2 {2, 3, . . . , n2 2},\nSi {1, 2, . . . , ni 2} for i = 3, 4, . . . , k 1, and Sk {1, 2, . . . , nk 1} is reachable.\nThis gives n1 1+2n2 3+n3 2+n4 2+ +nk 1 2+nk 1 = n1 1+(1/22k 2 )2n2 +n3 + +nk\nreachable states.\nMoreover, each singleton set is co-reachable in N via a string in a , except for {q}\nwhere q is a non-final state of A1 . By Lemma 1, the reachable states (i, S2 , S3 , . . . , Sk )\nand (j, T2 , T3 , . . . , Tk ) are distinguishable if they differ in a state of Ai with i 2 or\nin f1 . Next, the states (i, S2 , S3 , . . . , Sk ) and (j, S2 , S3 , . . . , Sk ) with 1 i < j < f1\nare sent to states that differ in f1 by bf1 j .", "Our next result shows that a trivial upper bound n1 2n2 +n3 + +nk can be met,\nup to a multiplicative constant depending on k, by the concatenation of k ternary\nlanguages. Thus, this trivial upper bound is asymptotically tight in the ternary case. Theorem 20.", "Let k 2, n1 3, n2 4, and ni 3 for i = 3, 4, . . .", ", k. There\nexist ternary DFAs A1 , A2 , . .", ". , Ak such that every DFA recognizing the concatenation L(A1 )L(A2 ) L(Ak ) has at least (1/22k 2 ) n1 2n2 +n3 + +nk states. Proof.", "Let us add the transitions on symbol c to the binary automata shown in\nFigure 15 as follows: c : (1, 2, . . .", ", n1 ) in A1 , c : (fi fi + 1) in Ai with 2 i k 1,\nand c : (1) in Ak . Construct the NFA N for L(A1 )L(A2 ) L(Ak ) with omitted dead\nstates as in the binary case; see Figure 17 for an illustration. As shown in the proof of\nTheorem 19, the subset automaton D(N ) has (1/22k 2 )2n2 +n3 + +nk reachable states\nof the form (f1 , S2 , S3 , .", ". . , Sk ).", "Each such state is sent to the state (j, S2 , S3 , . . .", ", Sk )\nwith 1 j f1 1 by the string cj . Moreover, in the NFA N , each singleton set\nis co-reachable via a string in a c . By Corollary 2, all states of D(N ) are pairwise\ndistinguishable.", "This gives the desired lower bound.", "7. Unary Languages\nThe upper bound on the state complexity of concatenation of two unary languages\nis n1 n2 , and this upper bound can be met by cyclic unary languages if gcd(n1 , n2 ) = 1\nas shown in [8, Theorems 5. 4 and 5.", "5]. This gives a trivial upper bound n1 n2 nk\nfor concatenation of k unary languages. Here we show that a tight upper bound for\nconcatenation of k cyclic unary languages is much smaller.", "Then we continue our\nstudy by investigating the concatenation of languages of the form a i Yi where Yi is\na λi -cyclic. In both cases, we provide tight upper bounds. Finally, we consider the\ncase, when automata may have final states in their tails.", "Recall that the state set of a unary automaton of size (λ, ) consists of a\ntail q0 , q1 , . . .", ", q 1 and a cycle p0 , p1 , . . .", ", pλ 1 (with p0 = q0 if = 0), and its\ntransitions are q0 q1 q 1 p0 p1 pλ 1 p0 ; cf. [6]. Let n1 , n2 , .", ". . , nk be positive integers with gcd(n1 , n2 , .", ". . , nk ) = 1.", "Then g(n1 , n2 , . . .", ", nk ) denotes the Frobenius number, that is, the largest integer\nthat cannot be expressed as x1 n1 + x2 n2 + + xk nk for some non-negative integers x1 , x2 , . . .", ", xk . Let us star with the following observation.", "State Complexity of Multiple Concatenation", "27\na, b", "c\na\nN", "s1 =1", "a, b\nc", "c", "b", "c", "s2 =1", "a", "c", "a, b\nc", "2\nb", "a, b", "2\nc", "s3 =1", "a, b", "s4 =1", "a, b", "c\na, b", "2", "b\nc", "f1 =4", "c", "a, b", "c", "a, b", "3", "a, b", "a, b", "3", "a, b", "a, b", "4", "f2 =5", "a, b", "a, b\nc", "6", "a, b", "c", "f3 =4", "a, b\nc", "f4 =4", "a, b", "5", "c", "c\n3", "c", "a, b", "c", "2", "c", "3", "c\na, b", "5", "a, b", "Figure 17: A ternary NFA for L(A1 )L(A2 )L(A3 )L(A4 ) where n1 = 4, n2 = 6, n3 = n4 = 5.", "Lemma 21. Let n1 , n2 , . . . , nk be positive integers with gcd(n1 , n2 , . . . , nk ) = d.\nThen each number of the form x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0,\nis a multiple of d. Furthermore, the largest multiple of d that cannot be represented\nas x1 n1 + x2 n2 + + xk nk , with x1 , x2 , . . . , xk 0, is d g( nd1 , nd2 , . . . , ndk ).\nProof. The first claim follows from the fact that each ni is a multiple of d.\nSince gcd( nd1 , nd2 , . . . , ndk ) = 1, the largest integer that cannot be represented\nas x1 nd1 + x2 nd2 + + xk ndk , with x1 , x2 , . . . , xk 0, is g( nd1 , nd2 , . . . , ndk ). Multiplying by d, we get the second claim.", "Let f (n1 , n2 , . . .", ", nk ) = g(n1 , n2 , . . .", ", nk ) + n1 + n2 + + nk be the modified\nFrobenius number, that is, the largest integer which is not representable by positive\ninteger linear combinations. Using this notation, we have the following result. Theorem 22.", "Let A1 , A2 , . . .", ", Ak be unary cyclic automata with n1 , n2 , . . .", ", nk\nstates, respectively. Let d = gcd(n1 , n2 , . .", ". , nk ). Then L(A1 )L(A2 ) L(Ak ) is recognized by a DFA of size (λ, ), where λ = d and = d f ( nd1 , nd2 , .", ". . , ndk ) k + 1,\nand this upper bound is tight.", "Proof. Denote Li = L(Ai ) and L = L1 L2 Lk . We show that L is recognized\nby a unary DFA of size (λ, ).", "By [6, Theorem 2], it is enough to show that for\nevery m d f ( nd1 , nd2 , . . .", ", ndk ) k + 1, we have am L if and only if am+d L. We can write each language Li as Li = Zi (ani ) where Zi = Li {ax | 0 x < ni };\ncf. [6, Proof of Theorem 8].", "Let m d f ( nd1 , nd2 , . . .", ", ndk ) k + 1. If am L, then m = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk where azi Zi", "28", "J. Jir sek, G. Jir skov", "and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, we get\nx1 n1 +x2 n2 + + xk nk d f (", "n1 n2\nnk\n, , . . . , ) k + 1 z1 z2 zk \nd d\nd", "n1 n2\nnk\n, , . . . , ) k + 1 (n1 1) (n2 1) (nk 1) =\nd d\nd\nn1 n2\nnk\nd g( , , . . . , ) + 1.\nd d\nd", "d f(", "Since x1 n1 + x2 n2 + + xk nk is a multiple of d, it follows from Lemma 21\nthat x1 n1 +x2 n2 + +xk nk +d = x 1 n1 +x 2 n2 + +x k nk for some x 1 , x 2 , . . . , x k 0.\nTherefore\nm + d = z1 + x 1 n1 + z2 + x 2 n2 + + zk + x k nk ,\nso am+d L.\nConversely, if am+d L, then m + d = z1 + x1 n1 + z2 + x2 n2 + + zk + xk nk\nwhere azi Zi and xi 0. Since m d f ( nd1 , nd2 , . . . , ndk ) k + 1, similarly as in\nthe previous paragraph, we get\nx1 n1 + x2 n2 + + xk nk d d g(", "nk\nn1 n2\n, , . . . , ) + 1,\nd d\nd", "and therefore x1 n1 + x2 n2 + + xk nk d = x 1 n1 + x 2 n2 + + x k nk for\nsome x 1 , x 2 , . . . , x k 0. Thus m = z1 +x 1 n1 +z2 +x 2 n2 + +zk +x k nk and am L.\nTo get tightness, consider unary cyclic languages Li = ani 1 (ani ) recognized by\nunary cyclic ni -state automata. Let L = L1 L2 Lk . As shown above, the language L\nis recognized by a unary DFA A with a tail of length d f ( nd1 , . . . , ndk ) k + 1 and a\ncycle of size d. Next, we have am L if and only if\nm = (n1 1) + (n2 1) + + (nk 1) + x1 n1 + x2 n2 + + xk nk\nfor some x1 , x2 , . . . , xk 0. Since x1 n1 + x2 n2 + + xk nk is a multiple of d, the\ncycle of size dn has\nexactly\none final state, and therefore it is minimal. Furthermore,\nnk\n1 n2\na string ad f ( d , d ,..., d ) k+ d is in L if and only if\nd f (", "n1 n2\nnk\n, , . . . , ) k+ d = (n1 1)+(n2 1)+ +(nk 1)+x1 n1 +x2 n2 + +xk nk\nd d\nd", "for some x1 , x2 , . . . , xk 0, which holds if and only if\nd g(", "n1 n2\nnk\n, , . . . , ) + d = x1 n1 + x2 n2 + + xk nk .\nd d\nd\nn1", "n2", "nk", "n1", "n2", "nk", "By Lemma 21, it follows that ad f ( d , d ,..., d ) k \n/ L, while ad f ( d , d ,..., d ) k+d L.\nHence A is minimal.", "By [3, Proposition 2.2], if n1 n2 nk , then g(n1 , n2 , . . . , nk ) n1 nk . This\ngives an upper bound n1 nk /d + n1 + + nk k + 1 + d for concatenation of k cyclic\nlanguages where n1 n2 nk and d = gcd(n1 , n2 , . . . , nk ). The result of the\nprevious theorem can be generalized as follows.", "State Complexity of Multiple Concatenation", "29", "Corollary 23. For i = 1, 2, . . . , Lk , let Li = a i Yi where Yi is λi -cyclic be\na language recognized by a DFA of size (λi , i ). Let d = gcd(λ1 , λ2 , . . . , λk ).\nThen the language L1 L2 Lk is recognized by a DFA of size (λ, ) where λ = d\nand = 1 + 2 + + k + d f ( λd1 , λd2 , . . . , λdk ) k + 1, and this upper bound is\ntight.\nProof. The language L1 L2 Lk is a concatenation of the singleton language a 1 + 2 + + k recognized by a DFA of size (1, 1 + 2 + + k + 1) and\nthe concatenation of cyclic languages Y1 Y2 Yk . Now the result follows from the\nprevious theorem since we can simply merge the final state of the automaton for the\nsingleton language with the initial state of the DFA for Y1 Y2 Yk ; cf. [6, Theorem 6].\nThe upper bound is met by languages Li = a i +λi 1 (aλi ) .", "In the case of concatenation of two languages, the length of the resulting cycle\nmay be equal to the least common multiple of the lengths of cycles in given automata\nproviding that they have final states in their tails [6, Theorems 10 and 11]. The next\nexample shows that in some cases this is the optimal way how to get the maximum\ncomplexity of concatenation of languages recognized by m-state and n-state unary\nDFAs, respectively. Example 24.", "Given an m-state and n-state unary DFA, their concatenation requires mn states if gcd(m, n) = 1. If gcd(m, n) > 1, then we may try to take DFAs\nwith smaller cycles of sizes m i and n j, and inspect the complexity of concatenation\nof languages recognized by automata of sizes (m i, i) and (n j, j). As shown in [6, Theorem 11] the minimal DFA for concatenation of the languages {ε} am 1 (am 2 ) and {ε} an 1 (an 2 ) , that are recognized by automata\nof sizes (m 2, 2) and (n 2, 2), with the set of final states {0, m 1} and {0, n 1},\nrespectively, has 2 lcm(m 2, n 2) + 3 states.", "By our computations, the smallest m and n, for which such automata provide the maximum complexity among all\nautomata of sizes (m i, i) and (n j, j), are m = 137 712 and n = 127 206. Nevertheless, it looks like sometimes it could be helpful to decrease the lengths\nof cycles not by two, but just by one, and setting the final state sets to {0, m 2}\nand {0, n 2}, respectively; our aim is to have a state in both tails, and then, to\nget minimal DFAs, the states m 1 and n 1 have to be non-final. Then, similarly\nas in the proof of [6, Theorem 11] we show that the minimal DFA recognizing the\nconcatenation of these two languages has 2 lcm(m 1, n 1) 1 states provided\nthat gcd(m 1, n 1) > 1 and neither m 1 nor n 1 is a multiple of the other.", "Our next goal is to find m and n such that the maximum of complexities of concatenation of languages recognized by all automata of sizes (m i, i) and (n j, j) is\nachieved if i = j = 1 and gcd(m 1, n 1) = 2 by the above mentioned languages. In such a case, we have 2 lcm(m 1, n 1) 1 = (m 1)(n 1) 1. By [6, Theorems 10 and 12], the complexity of concatenation of languages recognized by automata of sizes (m i, i) and (n j, j) is at most (m i)(n j) + i + j\nif gcd(m i, n j) = 1, and at most 2 lcm(m i, n j)+i+j 1 if gcd(m i, n j) > 1.", "In both cases, the resulting complexity is at most (m i)(n j) + i + j. Denote this", "30", "J. Jir sek, G. Jir skov", "number by ci,j = (m i)(n j) + i + j. The reader may verify that\nci,j < (m 1)(n 1) 1 for all i, j 1 and (i, j) = (1, 1),\nc0,j < (m 1)(n 1) 1 if j 2 and n + 2 < m,\nci,0 < (m 1)(n 1) 1 if i 3 and m < 2n 3.\nIf follows that the complexity (m 1)(n 1) 1 could possibly be exceeded only by\nautomata of sizes (m i, i) and (n j, j) where (i, j) {(0, 0), (0, 1), (1, 0), (2, 0)}.\nAssume that in all of this cases, we have gcd(m i, n j) 3. Then, providing\nthat m, n 8, the complexity of the corresponding concatenations in these four cases\nis at most\n2 lcm(m i, n j) + i + j 1 <", "2\n2\n(m i)(n j) + i + j mn + 3 < (m 1)(n 1) 1.\n3\n3", "Now, let m = 471 and n = 315. Then gcd(m 1, n 1) = 2 and n+2 < m < 2n 3.\nMoreover, we have gcd(471, 315) = 3, gcd(471, 314) = 157, gcd(470, 315) = 5,\nand gcd(469, 315) = 7. This means that the maximum complexity of concatenation of a 471-state and 315-state unary DFA is achieved by automata of sizes (470, 1)\nand (314, 1) recognizing languages {ε} a469 (a470 ) and {ε} a313 (a314 ) , that is, by\nautomata that have a final state in their tails.", "Motivated by our previous examples, we finally consider the state complexity of the\nconcatenation of k languages recognized by unary automata that have final states in\ntheir tails. While in our previous two theorems, the length of the resulting cycle was\nequal to the greatest common divisor of the lengths of cycles in the given automata,\nhere, similarly to the case of concatenation of two languages (cf. [6, Theorems 10, 11]),\nit may be equal to their least common multiple.", "We cannot obtain a tight upper bound\nhere, nevertheless, we provide an example that meets our upper bound. Theorem 25. For i = 1, 2, .", ". . , k, let Ai be a unary DFA of size (λi , i ).", "For a\nnon-empty set I = {i1 , i2 , . . .", ", i } {1, 2, . . .", ", k}, let\ndI = gcd(λi1 , λi2 , . . .", ", λi ),\nλi λi\nλi\nf (I) = f ( 1 , 2 , . . .", ", ),\ndI dI\ndI\nand set d = 1 and f ( ) = 0. Then the language L(A1 )L(A2 ) L(Ak ) is recognized\nby a DFA of size (λ, ) where\nλ = lcm(λ1 , λ2 , . .", ". , λk )\n = max{ 1 + 2 + + k k + 1 + dI f (I) | I {1, 2, . .", ". , k}}. Proof.", "Let Li = L(Ai ) and L = L(A1 )L(A2 ) L(Ak ). We have Li = Xi a i Yi\nwhere Xi = L(Ai ) {ax | 0 x < i } and Yi = {ax | a i +x L(A)}. Then\n[\nY\nY\nL=\nXj\na i Yi .", "I {1,2,. . .", ",k} j I\n/", "i I", "State Complexity of Multiple Concatenation", "31", "Q\nFor eachPI, the language j I\nby a DFA of\n/ Xj is a finite language recognized\nQ\n i\nsize (1, 1 + j I\n(", "1)),\nand\nby\nCorollary\n23,\nthe\nlanguage\na\nY\nis recognized\nj\ni\n/\ni I\nP\nby a DFA of size (dI , 1 + dI F (I) + i I ( i 1)).\nThe concatenation of these two languages is recognized by a DFA of\nsize (dI , 1 + 2 + + k k + 1 + dI f (I)); cf. [6, Theorem 6]. Then, the union\nof these concatenations is recognized by a DFA of size (λ, ) by [6, Theorem 4]. \nExample 26. Consider unary DFAs A1 , A2 , A3 of sizes (12, 2), (20, 2), and (30, 2),\nwith F1 = {0, 13}, F2 = {0, 21}, and F3 = {0, 31}.\nWe have lcm(12, 20, 30) = 60, 4 f (3, 5) = 6 f (2, 5) = 10 f (2, 3) = 60, and\n2 f (6, 10, 15) = 2 2 f (3, 5, 15) = 2 2 5 f (3, 1, 3) = 2 2 5 3 f (1, 1, 1) = 2 2 5 3 2 = 120.\nThe size of the minimal automaton recognizing the language L(A1 )L(A2 )L(A3 )\nis (60, 124) where 124 = 2 + 2 + 2 3 + 1 + max{60, 120}.", "The above example shows that our upper bound given by Theorem 25 is met by\nunary automata of sizes (12, 2), (20, 2), (30, 2). The tightness of this upper bound in\na general case remains open. 8.", "Conclusions\nWe examined in detail the state complexity of the multiple concatenation of k languages. First, we described witness DFAs A1 , A2 , . .", ". , Ak over the (k + 1)-letter\nalphabet {b, a1 , a2 , . .", ". , ak }, in which each ai performs the circular shift in Ai and\nthe identity in the other automata, while b performs a contraction. Using symbols a1 , a2 , .", ". . , ak , we proved the reachability of all valid states in the subset automaton for the concatenation by carefully setting the ith component without changing the\nalready set (i + 1)th component.", "The transitions on b guaranteed the co-reachability\nof all singleton sets in the NFA for concatenation, and therefore we obtained the proof\nof distinguishability of all states in the corresponding subset automaton for free. However, to get co-reachability of singletons, our witness automata were required to have\nat least three states. Nevertheless, we described witness automata over a (k +1)-letter\nalphabet also in the case where some of them have only two states.", "Then we provided special binary witnesses for the concatenation of two languages. Using our results concerning witnesses over a (k + 1)-letter alphabet, as well as the\nresults for the special binary automata, we described witnesses for the concatenation\nof k languages over a k-letter alphabet. This solves an open problem stated in [1].", "For k = 3, we proved that the ternary alphabet is optimal in the sense that the\nupper bound for the concatenation of three languages cannot be met by any binary\nlanguages. This provides a partial answer to the second open problem from [1]. We also considered multiple concatenation on binary and ternary languages, and\nobtained lower bounds n1 1+(1/22k 2 )2n2 +n3 + +nk and (1/22k 2 )n1 2n2 +n3 + +nk ,\nrespectively.", "This shows that the state complexity of multiple concatenation remains\nexponential in n2 , n3 , . . .", ", nk in the binary case, and that a trivial upper bound can\nbe met, up to a multiplicative constant depending on k, by ternary languages.", "32", "J. Jir sek, G. Jir skov", "Finally, we investigated multiple concatenation on unary languages. We obtained\na tight upper bound for cyclic languages, and we showed that for k 3, it is much\nsmaller than a trivial upper bound n1 n2 nk , which is met by cyclic unary languages\nif k = 2 and gcd(n1 , n2 ) = 1 [8, Theorem 5. 4].", "We also provided a tight upper bound\nfor languages recognized by automata that do not have final states in their tails. Some problems remain open. First, our k-letter witnesses require ni 3\nfor i = 2, 3, .", ". . , k 1, while the (2k 1)-letter witnesses in [4, Theorem 5] work\nwith ni 2.", "Is it possible to define k-letter witnesses also in such a case? We can do\nthis using k + 1 letters, or with k letters if all automata have two states. We proved the optimality of a ternary alphabet for the concatenation of three\nlanguages.", "However, we cannot see any generalization of the proof. Is a k-letter\nalphabet for describing witnesses for the concatenation of k languages optimal? Next, we provided upper bounds in the case where exactly one automaton has one\nstate, and using a binary alphabet we proved that they are tight if k = 2.", "What is\nthe state complexity of multiple concatenation if some languages may be equal to Σ ? Finally, in the unary case, we obtained an upper bound for multiple concatenation\nof languages recognized by unary automata that may have final states in their tails. The tightness of this upper bound remains open."]}
